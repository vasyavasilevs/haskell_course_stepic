1.1 –í–≤–µ–¥–µ–Ω–∏–µü§ØÔ∏è

–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä (–ö) –∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä (–ò–ü)
hs —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
–æ—Ç—Å—Ç—É–ø—ã —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω—ã
–≤—ã–∑—ã–≤–∞–µ–º—ã–π –≤ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä–µ (GHCi) —Ñ–∞–π–ª –¥–æ–ª–∂–µ–Ω —Ä–∞—Å–ø–æ–ª–∞–≥–∞—Ç—å—Å—è –≤ —Ç–æ–π –∂–µ –ø–∞–ø–∫–µ

module Test where
sayHello = putStrLn "Hello"

Prelude> :load Test - –∑–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥—É–ª—è
:reload - –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥—É–ª—è

1.2 –§—É–Ω–∫—Ü–∏–∏ü§ØÔ∏è

–ú–æ–¥–µ–ª—å –≤—ã—á–∏—Å–ª–µ–Ω–∏—è, —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –∏ –∏–º–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã—Ö —è–∑—ã–∫–æ–≤ (–∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ —è—á–µ–π–∫–∏ –ø–∞–º—è—Ç–∏)
–í —Ñ—É–Ω–∫—Ü - –ø—Ä–æ–≥—Ä–∞–º–º–∞ - –≤—ã—Ä–∞–∂–µ–Ω–∏–µ, —Ä–µ–¥—É–∫—Ü–∏–∏ –¥–æ –∫–æ–Ω—Ü–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π. –í—ã—á–∏—Å–ª–∏—Ç–µ–ª—å -
–≤–Ω–µ—à–Ω—è—è –ø—Ä–æ–≥—Ä–∞–º–º–∞
–í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –≤ —Å–∫–æ–±–∫–∞—Ö, —Å–∫–æ–±–∫–∏ –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
acos (cos pi)
–µ—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤, —Ç–æ f x y
–æ–ø–µ—Ä–∞—Ü–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–π –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–∞ –≤–ª–µ–≤–æ - (max 5) 42 = 42
(max 5) –±—É–¥–µ—Ç —Ñ—É–Ω–∫—Ü–∏–µ–π –æ–¥–Ω–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞
3 + sin 42 
3 + (max 5) 42 - —á–∞—Å—Ç–∏—á–Ω–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π

–°–∏–Ω—Ç–∞–∫—Å–∏—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π —Ñ—É–Ω–∫—Ü–∏–∏

sumSquares x y = x ^ 2 + y ^ 2
–∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏ —Å –º–∞–ª–µ–Ω—å–∫–æ–π –±—É–∫–≤—ã, –±–æ–ª—å—à–∞—è –¥–ª—è —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö
rock'n'roll = 42  
–≤ –ò–ü let func 
> func

—Å–≤–æ–π—Å—Ç–≤–æ —á–∏—Å—Ç–æ—Ç—ã —Ñ—É–Ω–∫—Ü–∏–π - –Ω–∏–∫–∞–∫–∏–µ –¥—Ä—É–≥–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –∫—Ä–æ–º–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ

let fortyTwo = 39 + 3 (always 42)
—Å–ª—É—á–∞–π–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ? –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä

—É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä
—É—Å–ª–æ–≤–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ let f x = if x > 0 then 1 else (-1) -–æ–±—ä–µ–∫—Ç—ã –æ–¥–Ω–æ–≥–æ —Ç–∏–ø–∞ –¥–æ–ª–∂–Ω—ã —Å—Ç–æ—è—Ç—å –ø–æ—Å–ª–µ –∑–µ–Ω –∏ –µ–ª—Å
f 5 = 1
f (-5) = -1 - —Å–∫–æ–±–∫–∏ –∏–º–µ—é—Ç –∑–Ω–∞—á–µ–Ω–∏–µ

let g x = (if x > 0 then 1 else (-1)) + 3

–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π —Å –ø–æ–º–æ—â—å—é —á–∞—Å—Ç–∏—á–Ω–æ–≥–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è 
let max5 x = max 5 x —Ä–∞–≤–Ω–æ—Å–∏–ª—å–Ω–æ max5' = max 5 - –±–µ—Å—Ç–æ—á–µ—á–Ω—ã–π —Å—Ç–∏–ª—å –ø—Ä–æ–≥–∏
let discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
let standardDiscount = discount 1000 5 (sum –Ω–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è)

1.3 –û–ø–µ—Ä–∞—Ç–æ—Ä—ãü§ØÔ∏è

max 6 7 - —Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã–∑—ã–≤–∞—é—Ç—Å—è –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω–æ–º —Å—Ç–∏–ª–µ
6 + 7 - –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã - –≤ –∏–Ω—Ñ–∏–∫—Å–Ω–æ–º

6 `max` 7 - —Ñ—É–Ω–∫—Ü–∏—è –≤ –æ–ø–µ—Ä–∞—Ç–æ—Ä–Ω–æ–º —Å—Ç–∏–ª–µ, –∑–∞–∫–ª—é—á–µ–Ω–∏–µ –≤ –æ–±—Ä–∞—Ç–Ω—ã–µ –∫–∞–≤—ã—á–∫–∏
(+) 6 7 - –æ–ø–µ—Ä–∞—Ç–æ—Ä –≤ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–º —Å—Ç–∏–ª–µ
–≤—Å–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –±–∏–Ω–∞—Ä–Ω—ã–µ, –ø—Ä–∏–Ω–∏–º–∞—é—Ç 2 –∑–Ω–∞—á–µ–Ω–∏—è, –∏—Å–∫–ª - –ø–µ—Ä–µ–¥ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏
–≤ —ç—Ç–æ–º –Ω–µ—É–¥–æ–±—Å—Ç–≤–æ, –ø–æ—ç—Ç–æ–º—É –∫–æ–≥–¥–∞ –æ—Ç—Ä–∏—Ü —á–∏—Å–ª–æ –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–µ —Ñ—É–Ω–∫—Ü–∏–∏, —Ç–æ –µ–≥–æ –Ω–∞–¥–æ –∑–∞–∫–ª—é—á–∞—Ç—å –≤ —Å–∫–æ–±–∫–∏, —Ç–∫ –∏–Ω–∞—á–µ –±—É–¥–µ—Ç —Ñ—É–Ω–∫—Ü–∏—è –º–∏–Ω—É—Å —á–∏—Å–ª–æ

–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
3 + 5 * 8 = 43
–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ—Ç 0 –¥–æ 9 –æ–±–æ–∑–Ω–∞—á–∞–µ—Ç—Å—è, –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Ñ—É–Ω–∫—Ü–∏–π - —Å–∞–º—ã–π –≤—ã—Å–æ–∫–∏–π (10)

–∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å
(3 - (9) - 5)
–æ–ø–µ—Ä–∞—Ç–æ—Ä –≤—ã—á–∏—Ç–∞–Ω–∏—è –ª–µ–≤–æ-–∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω—ã–π
–∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ infixl, infixr, infix (–Ω–µ —Ö–æ—Ç–∏–º —É–∫–∞–∑—ã–≤–∞—Ç—å –ª–µ–≤–æ–ø—Ä–∞–≤–æ), –ø–æ—Ç–æ–º —É—Ä–æ–≤–µ–Ω—å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ –∏ –∏–º—è (–æ–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ)

–∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
infixr 8 ^, `logBase` - –ø—Ä–∞–≤–∞—è –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å, 8 —É—Ä–æ–≤–µ–Ω—å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞. –§—É–Ω–∫—Ü–∏—è –ª–æ–≥–±–µ–π–∑ –∫–∞–∫ –æ–ø–µ—Ä–∞—Ç–æ—Ä —Ç–∞–∫–∞—è –∂–µ
infixl 7 *, /, `div`, `mod`
infixl 6 +, -
infix 4 ==, /=, >, >=, <, <=
–∫–æ–≥–¥–∞ –Ω–∏—á–µ–≥–æ –Ω–µ –∑–∞–¥–∞–Ω–æ, —Ç–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∞—Å—Å–æ—Ü –ª–µ–≤–∞—è, –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç 9

–Ω–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤, –≤—Å–µ –æ–Ω–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ
–º–æ–∂–Ω–æ —Å–∞–º–æ–º—É –¥–µ–ª–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –∏–∑ –Ω–∞–±–æ—Ä–∞ —Å–∏–º–≤–æ–ª–æ–≤ 
{! # $ % * + . / < = > ? @ \ ^ | - ~} - —Ä–∞–≤–Ω–æ–∑–Ω–∞—á–Ω—ã
–º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ—â–µ :, –Ω–æ –Ω–µ –≤ –Ω–∞—á–∞–ª–µ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞

module Demo where

infixl 6 *+*

a *+* b = a ^ 2 + b ^ 2 (—Ä–∞–≤–Ω–æ—Å–∏–ª—å–Ω–æ (*+*) a b = a ^ 2 + b ^ 2)

–µ–≥–æ –º–æ–∂–Ω–æ –±—ã–ª–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –≤ –≤–∏–¥–µ 3 *+* 4 = 25 –∏ (*+*) 3 4

—á–∞—Å—Ç–∏—á–Ω–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –∫ –æ–¥–Ω–æ–º—É –∏–∑ —Å–≤–æ–∏—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
(/) 2 —ç–∫–≤–∏–≤ (2 /) - —Å–µ—á–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ (—Ñ—É–Ω–∫—Ü–∏—è –æ–¥–Ω–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞)
(2 /) 4 = 0.5 –¥–≤–∞ –¥–µ–ª–∏—Ç—å –Ω–∞ 4 —Ä–∞–≤–Ω–æ 1/2
(/ 2) 4 = 2 —á–µ—Ç—ã—Ä–µ –¥–µ–ª–∏—Ç—å –Ω–∞ –¥–≤–∞ —Ä–∞–≤–Ω–æ 2
–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã —Å–∫–æ–±–∫–∏
–µ—Å—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ (- 2) - —ç—Ç–æ –Ω–µ —Å–µ—á–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ -, –∞ —á–∏—Å–ª–æ -2

–∑–Ω–∞—á–æ–∫ –ø—Ä–æ–±–µ–ª–∞
module Demo where

f $ x = f x
sin 0 = 0 —ç–∫–≤–∏–≤ sin $ 0 = 0
–æ–ø–µ—Ä–∞—Ç–æ—Ä –¥–æ–ª–ª–∞—Ä —Å–∞–º—ã–π –Ω–∏–∑–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏–º–µ–µ—Ç, –∏–º –º–æ–∂–Ω–æ –æ—Ç —Å–∫–æ–±–æ–∫ –∏–∑–±–∞–≤–ª—è—Ç—å—Å—è
sin (pi / 2) —ç–∫–≤–∏–≤ sin $ pi / 2
—É –¥–æ–ª–ª–∞—Ä–∞ –ø—Ä–∞–≤–∞—è –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å

{--} - comment
{- f (g x (h y)) == f $ g x (h y) == f $ g x $ h y -}

logBase x $ y –º–µ–∂–¥—É –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏ —ç—Ç—É —Ö—Ä–µ–Ω—å –Ω–∞–¥–æ —Å—Ç–∞–≤–∏—Ç—å........

–ë–∞–∑–æ–≤—ã–µ —Ç–∏–ø—ãü§ØÔ∏è

–¢–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —è–∑—ã–∫ —Å–æ —Å—Ç—Ä–æ–≥–æ–π (–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–µ—è–≤–Ω–æ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–æ–≤) —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–π (–ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –Ω–µ –≤–æ –≤—Ä–µ–º—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è, –∞ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏) —Å–∏—Å—Ç–µ–º–æ–π —Ç–∏–ø–∏–∑–∞—Ü–∏–∏

–≤—ã—è—Å–Ω–µ–Ω–∏–µ —Ç–∏–ø–æ–≤ - –∫–æ–º–∞–Ω–¥–∞ :type 
> :type 'c' 
'c' :: Char
'\n' is char too
> :type 'zz' - error
> :type True = Type :: Bool
> :t False -//-

–µ—Å—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –Ω–∞–±–æ—Ä —Ç–∏–ø–æ–≤, common name Num
> :t 3
3 :: Num a => a

> let x = 3 :: Int

> :t 3.5
Fractional a => a

Function type is declared by binary operator - arrow (->) (infixr)
not False = True 
> :t not 
not :: Bool -> Bool

> (&&) False True (logical operator && in functional style, returns True if both of arguments are true)
False

> ((&&) False) True 
        |        |
    Bool func Bool item
eventually, type of && is Bool -> (Bool -> Bool) (input: Bool, output: func Bool -> Bool)
parentheses may be not mentioned, finally 
> :t (&&)
(&&) :: Bool -> Bool -> Bool
number of arguments the same as number of arrows

–¢–∏–ø —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–∂–Ω–æ –∑–∞–¥–∞—Ç—å –≤ —Ñ–∞–π–ª–µ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ –≤–º–µ—Å—Ç–µ —Å –µ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º:

discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum

–û—Ç–º–µ—Ç–∏–º, —á—Ç–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, —Ö–æ—Ç—è —á–∞—Å—Ç–æ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏. –ï–≥–æ –æ–±—ã—á–Ω–æ —Ä–∞—Å–ø–æ–ª–∞–≥–∞—é—Ç –ø–µ—Ä–µ–¥ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º —Ñ—É–Ω–∫—Ü–∏–∏, —Ö–æ—Ç—è —ç—Ç–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è –º–æ–∂–Ω–æ —Ä–∞—Å–ø–æ–ª–æ–∂–∏—Ç—å –≤ –ª—é–±–æ–º –º–µ—Å—Ç–µ —Ñ–∞–π–ª–∞ —Å –∏—Å—Ö–æ–¥–Ω—ã–º –∫–æ–¥–æ–º

–Ω–µ –≤—Å–µ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã —á–µ—Ä–µ–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –ø—Ä–µ–ª—é–¥–∏—é, –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –Ω—É–∂–µ–Ω –Ω–æ–≤—ã–π –º–æ–¥—É–ª—å –∏ –∏–º–ø–æ—Ä—Ç –µ–≥–æ

module Demo where

import Data.Char

test = isDigit '7'

output = True

import of module may be done in ghci directly

–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é twoDigits2Int, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –¥–≤–∞ —Å–∏–º–≤–æ–ª–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∏—Å–ª–æ, —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–µ –∏–∑ —ç—Ç–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤, –µ—Å–ª–∏ –æ–±–∞ —Å–∏–º–≤–æ–ª–∞ —á–∏—Å–ª–æ–≤—ã–µ, –∏ 100 –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ. (–ü–µ—Ä–≤—ã–π —Å–∏–º–≤–æ–ª —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç—Å—è –∫–∞–∫ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Å—è—Ç–∫–æ–≤, –≤—Ç–æ—Ä–æ–π ‚Äî –µ–¥–∏–Ω–∏—Ü.)

import Data.Char
twoDigits2Int :: Char -> Char -> Int
twoDigits2Int x y = if isDigit x && isDigit y == True then digitToInt x * 10 + digitToInt y else 100 

–ö–æ—Ä—Ç–µ–∂ - —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π –Ω–∞–±–æ—Ä —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã, —Ç–∏–ø —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–± –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π
> (2, True) - 2-items kortege
(2, True) 
> fst (2, True)
2
> snd (2, True)
True
> :t ('x', True)
('x', True) :: (Char, Bool)

> (3) - one-element kortege does not exist! but exists empty kortege
> ()
()
> :t ()
() :: () 

–°–ø–∏—Å–∫–∏ - –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–Ω—ã–µ —Ç–∏–ø—ã, –Ω–æ –µ—Å—Ç—å –¥–≤–∞ –æ—Ç–ª–∏—á–∏—è –æ—Ç –∫–æ—Ä—Ç–µ–∂–µ–π:
1. –°–ø–∏—Å–∫–∏ –≥–æ–º–æ–≥–µ–Ω–Ω—ã (–∫–æ—Ä—Ç–µ–∂–∏ –≥–µ—Ç–µ—Ä–æ–≥–µ–Ω–Ω—ã) - –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å–ø–∏—Å–∫–∞ –¥–æ–ª–∂–Ω—ã –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç—å –∫ –æ–¥–Ω–æ–º—É —Ç–∏–ø—É
2. –î–ª–∏–Ω–∞ —Å–ø–∏—Å–∫–∞ –Ω–µ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞ –∏ –Ω–µ –∏–∑–≤–µ—Å—Ç–Ω–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É

> [1,2,3] - list of digits
> [False, True]
> :t [False, True]
[False, True] :: [Bool]
 
For char there is a special form of otput list - string
> ['H', 'i']
"Hi"
> "Hi" :: String


: - operator of adding one element at the head of a list
> let str = 'H' : "ello"
> str
"Hello"

++ - concatenation of two lists
> str ++ " world"
"Hello world"

1.5 –†–µ–∫—É—Ä—Å–∏—è ü§ØÔ∏è

–í —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö —è–∑—ã–∫–∞—Ö –Ω–µ—Ç –ø–æ–Ω—è—Ç–∏—è —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∏ —Ü–∏–∫–ª –∑–∞–º–µ–Ω—è–µ—Ç—Å—è —Ä–µ–∫—É—Ä—Å–∏–µ–π.

factorial n = if n == 0 then 1 else n * factorial (n - 1)

To avoid cycles we need 
1.to put not the same value of parameter in the right part of the func towards left part of the func (n =! n - 1)
2.terminate condition (if n == 0 then 1) reqursion interrupts


{-
factorial 2
 ~> if 2 == 0 then 1 else 2 * factorial 1
 ~> 2 * factorial 1
 ~> 2 * (if 1 == 0 then 1 else 1 * factorial 0)
 ~> 2 * 1 * factorial 0
 ~> 2 * factorial 0
 ~> 2 * (if 0 == 0 then 1 else 0 * factorial(-1))
 ~> 2 * 1
 ~> 2
-}

calculations are made directly in language

if-then-else is not comfortable enough for using, so exists comparement with origin: not alone equation

factorial' 0 = 1
factorial' n = n * factorial' (n - 1)

another description of parameters
n - irrefutable origin

reqursion from negative argument - fail
funcs error & indefined

> error "ABC" - outputs error message
*** Exception: ABC
> undefined - interrupts code immediately
*** Exception: Prelude.undefined 

undefined returns bottom symbol, it is used as an element of all types

adjusting
factorial'' 0 = 1
factorial'' n = if n < 0 then error "arg must be >= 0" else n * factorial'' (n - 1)

> factorial'' (-3) 
*** -/-

comparement with origin is not universal method, so there are guards
factorial''' 0 = 1
factorial''' n | n < 0 = error "arg must be >= 0" //guard 1
               | n > 0 = n * factorial''' (n - 1) //guard 2
bool
factorial4 n | n == 0		= 1
	     | n < 0 		= n * factorial''' (n - 1) 
             | otherwise 	= error "arg must be >= 0"

otherwise = True

we also may develop smth like loop by additional variable
factorial5 n | n >= 0 	= helper 1 n
	     | otherwise = error "arg must be >= 0"
	     
helper acc 0 = acc
helper acc n = helper (acc * n) (n - 1)

raise effectivity


1.6 –õ–æ–∫–∞–ª—å–Ω—ã–µ —Å–≤—è–∑—ã–≤–∞–Ω–∏—è –∏ –ø—Ä–∞–≤–∏–ª–∞ –æ—Ç—Å—Ç—É–ø–æ–≤ ü§ØÔ∏è

–î–≤—É–º–µ—Ä–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å, —Ä–∞—Å–ø–æ–∑–Ω–∞—é—Ç—Å—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º
—Ç–∞–± - 8 –ø—Ä–æ–±–µ–ª–æ–≤
—É–≤–µ–ª–∏—á–µ–Ω–∏–µ –æ—Ç—Å—Ç—É–ø–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ, —É–º–µ–Ω—å—à–µ–Ω–∏–µ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –ø—Ä–æ–±–ª–µ–º–∞–º

module Demo where

roots:: Double -> Double -> Double 
	-> (Double, Double) it is law-acceptable
roots a b c = 
  (
    (-b - sqrt (b^2 - 4 * a * c)) / (2 * a)
  ,
    (-b + sqrt (b^2 - 4 * a * c)) / (2 * a)
  )
  
null tab is global declaration
in a body of a func we can use any non-null tap

–≤ –∫–æ–¥–µ –≤—ã—à–µ –∫–æ–ø–∏—Ä—É–µ—Ç—Å—è –∫–æ—Ä–µ–Ω—å –∏–∑ –¥–∏—Å–∫—Ä–∏–º, —Ö–æ—á–µ—Ç—Å—è –∑–∞–≤–µ—Å—Ç–∏ –ª–æ–∫–∞–ª—å–Ω–æ-–æ–ø—Ä–µ–¥ –ø–µ—Ä–µ–º–µ–Ω –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–µ (let in)


roots' a b c = 
    let d = sqrt (b^2 - 4 * a * c) in 
    ((-b - d) / (2 * a), (-b + d) / (2 * a))

//e.g. let k in f(k)

> let x = True in (True, x)
(True, True)

let in can declare multiple bindings

roots'' a b c = 
    let {d = sqrt (b^2 - 4 * a * c); x1 = (-b - d) / (2 * a); x2 = (-b + d) / (2 * a)} in 
    (x1, x2)
    
more comfortable is version of declaring with tabs instead of ;
roots''' a b c =
 let
    x1 = (-b - d) / aTwice
    x1 = (-b + d) / aTwice
    d = sqrt $ b^2 - 4 * a * c
    aTwice = 2 * a
 in (x1, x2)
 
local bindings must have the same size of tabs

also we can declare local functions

factorial5 n | n >= 0 	= helper 1 n
	     | otherwise = error "arg must be >= 0"
	     
helper acc 0 = acc
helper acc n = helper (acc * n) (n - 1)

factorial6 n 
	| n >= 0 = let
	    helper acc 0 = acc
	    helper acc n = helper (acc * n) (n - 1)
	  in helper 1 n
	| otherwise = error "arg must be >= 0"

also exists local binding of origins

rootsDiff a b c = let
   (x1, x2) = roots a b c
   in x2 - x1
   
(x2, x1) - origin (//aka local variable in other lang-s)

local bindings with 'where'
where^(-1) = let in

roots''' a b c =
 let
    x1 = (-b - d) / aTwice
    x1 = (-b + d) / aTwice
    d = sqrt $ b^2 - 4 * a * c
    aTwice = 2 * a
 in (x1, x2)
 
roots'''' a b c = (x1, x2) where
    x1 = (-b - d) / aTwice
    x2 = (-b + d) / aTwice
    d = sqrt $ b^2 - 4 * a * c
    aTwice = 2 * a
    
differency in properties 

> let x = 2 in x^2
4
> x^2 where x = 2 
does not work

factorial6 n 
	| n >= 0 = let
	    helper acc 0 = acc
	    helper acc n = helper (acc * n) (n - 1)
	  in helper 1 n
	| otherwise = error "arg must be >= 0"

factorial7 n 
	| n >= 0 	= helper 1 n
	| otherwise 	= error "arg must be >= 0"
 where
  helper acc 0 = acc
  helper acc n = helper (acc * n) (n - 1)
  
in factorial7 we can use helper in all guards



2.1 –ü–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º (1) ü§ØÔ∏è

–§—É–Ω–∫—Ü–∏—è –æ–±–ª–∞–¥–∞–µ—Ç –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã–º –ø–æ–≤–µ–¥–µ–Ω–∏–µ–º, –µ—Å–ª–∏ –æ–Ω–∞ –º.–±. –≤—ã–∑–≤–∞–Ω–∞ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è—Ö —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ (int + int, double + double, + –ø–æ–ª–∏–º–æ—Ä—Ñ–µ–Ω)

2 —Ç–∏–ø–∞: –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π

–ü–∞—Ä–∞–º: –∫–æ–¥ —Ñ—É–Ω–∫—Ü–∏–∏ –æ–¥–∏–Ω–∞–∫–æ–≤ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤

+ - —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π, –ø–æ—Ç–æ–º—É —á—Ç–æ —á–∏—Å–ª–∞ –Ω–∞ –Ω–∏–∑–∫–æ–º —É—Ä–æ–≤–Ω–µ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏ (—Ñ–ª–æ—Ç, –∏–Ω—Ç) —Å–∫–ª–∞–¥—ã–≤–∞—é—Ç—Å—è –ø–æ-—Ä–∞–∑–Ω–æ–º—É

–ü—Ä–∏–º–µ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏ –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
>let id x = x
>id :: t -> t //t - –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–π —Ç–∏–ø, –ª—é–±–æ–µ –≤–º–µ—Å—Ç–æ –Ω–µ–≥–æ –º–æ–∂–Ω–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å


>id id
> :t (id id) 
(t -> t) -> (t -> t) = t -> t


> let k x y = x
> k 42 True
42
> :t k
k :: t1 -> t -> t1
> :t const - —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
a -> b -> a

> undefined //–∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è, —Ç–∏–ø –ª—é–±–æ–π, –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã
*** exception

–º–æ–∂–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å —Å—Ç–µ–ø–µ–Ω—å –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º–∞ —Ñ—É–Ω–∫—Ü–∏–∏, —è–≤–Ω–æ —É–∫–∞–∑–∞–≤ –µ–µ —Ç–∏–ø

mono :: Char -> Char //–º–æ–Ω–æ–º–æ—Ä—Ñ–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Å –±–æ–ª–µ–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º —Ç–∏–ø–æ–º, —á–µ–º id
mono x = x


semiMono :: Char -> a -> Char //—á–∞—Å—Ç–∏—á–Ω–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º–∞
semiMono x y = x


—Ñ—É–Ω–∫—Ü–∏—è –≤—ã—Å—à–∏—Ö –ø–æ—Ä—è–¥–∫–æ–≤ - —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –¥—Ä—É–≥—É—é —Ñ—É–Ω–∫—Ü–∏—é, –ø—Ä–∏–º–µ—Ä –≤ —Å–∏ - qsort

> :t ($)
(a -> b) -> a -> b    //()-—Ñ—Ü–∏—è, –∞—Ä–≥—É–º–µ–Ω—Ç - –ø—Ä–∏–º–µ–Ω—è–µ—Ç —Ñ—Ü–∏—é –∫ –∞—Ä–≥—É–º–µ–Ω—Ç—É 

> :t apply2 f x = f (f x)
(t -> t) -> t -> t //–∑–¥–µ—Å—å a –∏ b - –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ = t 

> apply2 (+5) 22
32
> apply (++ "AB") "CD"
"CDABAB"

flip f y x = f x y - standard lib

> flip (/) 4 2
0.5
> (/) 4 2
2

> flip const 5 True
True

–µ—Å—Ç—å –∞–Ω–æ–Ω–∏–º–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
> 2 * x + 7
error
>let f x = 2 * x + 7
> f 10
27

–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ (–ª—è–º–±–¥–∞-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ)
> (\x -> 2 * x + 7) 10
27

> let f' = \x -> 2 * x + 7
> f' 10
27

> let lenVec x y = sqrt $ x^2 + y^2
> let lenVec = \x -> \y-> sqrt $ x^2 + y^2
> lenVec 3 4 
5
–º–æ–∂–Ω–æ –µ—â–µ —Ç–∞–∫ 
> let lenVec = \x y -> sqrt $ x^2 + y^2

—á–∞—Å—Ç–æ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –≤ —Ñ—É–Ω–∫—Ü–∏—è—Ö –≤—ã—Å—à–∏—Ö –ø–æ—Ä—è–¥–∫–æ–≤

> let p1 = ((1,2), (3,4))
> let p2 = ((3,4), (5,6))
> fst $ fst p1
1


sumFstFst = (+) `on` helper
	where helper pp = fst $ fst pp
	

>sumFstFst p1 p2 
4 //—Å–ª–æ–∂–∏–ª–∏—Å—å –ø–µ—Ä–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ø–∞—Ä

–ù–û 
sumFstFst' = (+) `on` (\pp -> fst $ fst pp) - —Ç–∞–∫ –≥–æ—Ä–∞–∑–¥–æ –ª—É—á—à–µ


2.2 –ü–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º (2) ü§ØÔ∏è

f –∏ g, –Ω–∞–¥–æ –Ω–∞–ø–∏—Å–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏
> f :: b -> c
> g :: a -> b
> x :: a

> f (g x) :: c 
–Ω–∞–ø–∏—à–µ–º —Ç–µ–ø–µ—Ä—å —Ñ—É–Ω–∫—Ü–∏—é, —Ç–æ –µ—Å—Ç—å –∞–±—Å—Ç—Ä–∞–≥–∏—Ä—É–µ–º—Å—è –ø–æ –∏–∫—Å—É, —Ç–æ –µ—Å—Ç—å –Ω–∞–ø–∏—à–µ–º –ª—è–º–±–¥–∞-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ
—É—Å–ª–æ–≤–Ω–æ h x = f (g x) - –ø–µ—Ä–µ–º–µ—â–∞–µ–º –∏–∫—Å –≤–ø—Ä–∞–≤–æ –∏ —É–±–∏—Ä–∞–µ–º —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∞—à
> \x -> f (g x) :: a -> c
> let compose f g = \x -> f (g x)
> :t compose
compose :: (t1 -> t) -> (t2 - t1) -> t2 -> t1 aka a b c

–≤ —Ö–∞—Å–∫–µ–ª–ª–µ —É–∂–µ –æ–ø–µ—Ä–µ–¥–µ–ª–µ–Ω —Ç–∏–ø –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –∫–∞–∫ –≤—ã—à–µ:
> :i (.) // :i - info


–±—ã–ª–æ —Ä–∞–Ω—å—à–µ:
sumFstFst' = (+) `on` (\pp -> fst $ fst pp) - —Ç–∞–∫ –≥–æ—Ä–∞–∑–¥–æ –ª—É—á—à–µ

sumFstFst'' = (+) `on` (fst . fst)

{-
–¶–µ–ø–æ—á–∫–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–π –º.–±. –∑–∞–º–µ–Ω–µ–Ω–∞ –∫–æ–º–ø–æ–∑–∏—Ü–∏–µ–π
doIt x = f (g (h x)) = f ((g . h) x) = (f . (g . h)) x - x –ø–æ—Å–ª–µ–¥–Ω–∏–π –∞—Ä–≥—É–º–µ–Ω—Ç, –ø–æ—ç—Ç–æ–º—É –º–æ–∂–Ω–æ –µ–≥–æ —Å –¥–≤—É—Ö —Å—Ç–æ—Ä–æ–Ω –Ω–µ –ø–∏—Å–∞—Ç—å
doIt = f . g . h
-}


–°–ø–∏—Å–∫–∏ –∏ –∫–æ—Ä—Ç–µ–∂–∏ —Ç–æ–∂–µ –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã, –∫–∞–∫ –∏ —Ñ—É–Ω–∫—Ü–∏–∏
–°–ø–∏—Å–∫–∏:
> :t [True, False] - —Å–ø–∏—Å–æ–∫ –±—É–ª–µ–≤—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
:: [Bool]
> :t "aqaqa" 
:: [Char]
–ø–æ–ª–∏–º–æ—Ä—Ñ–Ω–æ—Å—Ç—å –≤ —Ç–æ–º, —á—Ç–æ –º—ã –º–æ–∂–µ–º –∑–∞–ø–æ–ª–Ω—è—Ç—å –ª—é–±—ã–º–∏ —Ç–∏–ø–∞–º–∏, –∏ –æ–Ω–∏ –±—É–¥—É—Ç –ø–æ—è–≤–ª—è—Ç—å—Å—è –≤ –≤—ã–≤–æ–¥–µ —Ç–∏–ø–∞ —Å–ø–∏—Å–∫–∞ 
> :t []
:: [a]
> :t (++)
:: [a] -> [a] -> [a]
> :t (:) - –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –≥–æ–ª–æ–≤—É —Å–ø–∏—Å–∫–∞
:: a -> [a] -> [a]

–ö–æ—Ä—Ç–µ–∂–∏:
—Ä–∞–Ω—å—à–µ: (True, 3) - –¥–≤—É—Ö—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–π –∫–æ—Ä—Ç–µ–∂ - –º–∏–∫—Å—Ñ–∏—Å–∫—Å–Ω—ã–π —Å—Ç–∏–ª—å
—Ç–µ–ø–µ—Ä—å: (,) True 3 - –ø—Ä–µ—Ñ–∏–∫—Å–Ω—ã–π —Å—Ç–∏–ª—å –∫–æ–Ω—Å—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∞—Ä—ã
(,,) True 3 'c' - —Ç–æ–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
> :t (,)
:: a -> b -> (a,b) - —Ç–æ–∂–µ –ø–æ–ª–∏–º–æ—Ä—Ñ–µ–Ω
> let dup x = (x, x)




–ö–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (—Ñ—É–Ω–∫—Ü–∏—è –Ω–∞–¥ –ø–∞—Ä–æ–π –¥–∞–ª–µ–µ) - —Ñ—É–Ω–∫—Ü–∏–∏, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –Ω–µ –≤—Å–µ —Ç—Ä–µ–±—É–µ–º—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã, –ø–æ—ç—Ç–æ–º—É –Ω–∞ –≤—ã—Ö–æ–¥–µ —Ç–æ–∂–µ –ø–æ–ª—É—á–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è —Ç—Ä–µ–±—É–µ—Ç –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã
–í—Å—Ç–∞–µ—Ç –≤–æ–ø—Ä–æ—Å –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫ –Ω–µ–∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∏ –Ω–∞–æ–±–æ—Ä–æ—Ç


> fst (1,2) - –º–æ–∂–µ–º —Å–º–æ—Ç—Ä–µ—Ç—å –∫–∞–∫ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—é –¥–≤—É—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ - –Ω–µ–∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è, –æ–Ω–∞ –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –æ–¥–Ω–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞
1
> :t on - —Ñ—É–Ω–∫—Ü–∏—è –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞, –ø–µ—Ä–≤—ã–π –µ–µ –∞—Ä–≥—É–º–µ–Ω—Ç - –∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
:: (b -> b -> c) -> (a -> b) -> a -> a -> c
> :t fst `on` (^ 2) 
error, –ø–µ—Ä–µ–¥–∞–ª–∏ –Ω–µ–∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—É—é 
> curry fst `on` (^ 2) - –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–≤—É—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤


module Demo where

import Data.Function

avg :: (Double, Double) -> Double
avg p = (fst p + and p) / 2

avg - –Ω–µ–∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è
> curry avg `on` (^2) - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ –¥–≤—É—Ö –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã—Ö –≤ –Ω–µ–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
> let cur f x y = f (x,y)
cur :: ((t1, t2) -> t) -> t1 -> t2 -> t - –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –Ω–µ–∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –∏ –≤–æ–∑–≤—Ä–∞—â –Ω–æ—Ä–º–∞–ª—å–Ω—É—é
—É –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–π curry —Ç–æ—Ç –∂–µ —Ç–∏–ø
> uncurry - –Ω–∞–æ–±–æ—Ä–æ—Ç


2.3 –ö–ª–∞—Å—Å—ã —Ç–∏–ø–æ–≤ ü§ØÔ∏è

–ü–æ–≥–æ–≤–æ—Ä–∏–º –ø—Ä–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º
–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å - –∫–ª–∞—Å—Å —Ç–∏–ø–æ–≤, –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ

> :t 7
:: Num a(–∫–æ–Ω—Ç–µ–∫—Å—Ç - –∏–º—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∫ —Ç–∏–ø—É (–∞–∫–∞ –Ω–∞–∫–ª–∞–¥—ã–≤–∞–Ω–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –Ω–∞ —Ç–∏–ø)) => a (—Ç–∏–ø) - –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã–π —Ç–∏–ø

> :t (+)
:: Num a => a -> a -> a

> :t (>)
:: Ord a => a -> a -> Bool // a –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª–µ–º –∫–ª–∞—Å—Å–∞ —Ç–∏–ø–æ–≤ Ord

> :t (> 7) - —Å–µ—á–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –±–æ–ª—å—à–µ —á–∏—Å–ª–æ–º 7
:: (Num a, Ord a) => a -> Bool

> :t (> (1, 2))
:: (Num t, Num t1, Ord t, Ord t1) => (t, t1) -> Bool //t t1 —Ç–∫ –≤ –ø–∞—Ä–µ –º–æ–≥—É—Ç –±—ã—Ç—å —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã

> :t (* 'c')
error

class Eq a where
    (==) :: a -> a -> Bool --numerate of functions' signatures
    (/=) :: a -> a -> Bool

{-
> :t (== 42)
:: (Eq a, Num a) => a -> Bool
-}

> :t elem - –ø—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª –ª–∏ —ç–ª–µ–º–µ–Ω—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–º —Å–ø–∏—Å–∫–∞
:: Eq a => a -> [a] -> Bool

–†–∞–∑–≥–æ–≤–æ—Ä –æ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—è—Ö –∫–ª–∞—Å—Å–∞ —Ç–∏–ø–æ–≤ + –º–µ—Ç–æ–¥—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

class Eq a where
    (==), (/=) :: a -> a -> Bool --numerate of functions' signatures
    x /= y = not (x == y)
    x = y = not (x /= y)

instance Eq Bool where
    True == True = True
    False == False = True
    _ == _ = False -- _ otherwise for all cases

    -- x /= y = not (x == y) that expression suits all the instances of class, 
    -- so we can raise it up straight to the class. We can overcover default definition

{- 
> :t (== 42)
:: (Eq a, Num a) => a -> Bool
-}

instance –º–± –∏ –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã–π —Ç–∏–ø, –Ω–∞–ø—Ä–∏–º–µ—Ä –ø–∞—Ä–∞
—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç–∏–ø—ã –Ω–µ –º–æ–≥—É—Ç —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å—Å—è –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞, —Ç–µ –Ω–µ —è–≤–ª –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—è–º–∏ –∫–ª–∞—Å—Å–∞ Eq


2.4 –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∫–ª–∞—Å—Å—ã —Ç–∏–ø–æ–≤ ü§ØÔ∏è

class extension - —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
–∫–∞–∫ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –≤ –æ–æ–ø - –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤


module Demo where

class Eq a where
    (==), (/=) :: a -> a -> Bool --numerate of functions' signatures
    x /= y = not (x == y)
    x = y = not (x /= y)
    
//—ç—Ç–æ –Ω–∞—Å–ª–µ–¥–Ω–∏–∫ –±—É–¥–µ—Ç
class (Eq a) => Ord a where //(Eq a) => - –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –∫–ª–∞—Å—Å–∞ —Ç–∏–ø–æ–≤ Ord, Ord —Ä–∞—Å—à–∏—Ä—è–µ—Ç Eq
    (<), (<=), (>=), (>) :: a -> a -> Bool
    max, min :: a -> a -> a
    compare :: a -> a -> Ordering
{-Minimal complete definition: either compare or <= -} 

> :t Ordering
data Ordering = LT | EQ | GT - 3 –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞, 3 —ç–ª–µ–º–µ–Ω—Ç–∞ (–º–µ–Ω—å—à–µ, —ç–∫–≤–∏–≤, –±–æ–ª—å—à–µ)

//–º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Ç–∞–∫–∂–µ –¥–æ–ø—É—Å—Ç–∏–º–æ
class (Eq a, Printable a) => MyClass a where
	... 
	
–ø–æ–¥ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ–º –ø–æ–Ω–∏–º–∞–µ—Ç—Å—è –Ω–µ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–π, –∞ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤

–ø—Ä–æ –º–µ—Ç–æ–¥ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤—Ö–æ–¥–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤ –µ–≥–æ —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
>:t show
show :: Show a => a -> String

> show 5.0
"5.0"

> :t read
read :: Read a => String -> a

> read "5" - error, –Ω–∞–¥–æ —Å–Ω—è—Ç—å –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º 5
> read "5" :: Int
5

> read "5 rings" :: Int - error

> reads "5 rings" :: [(Int, String)]
[(5, "rings")]


module Demo where

class Enum a where 
	succ, pred :: a -> a
	toEnum :: Int -> a
	fromEnum :: a -> Int
	
–∏—Ç–µ—Ä–∞—Ü–∏–∏ –ø–æ —Ç–∏–ø—É
> succ 4 
5
> pred 4
3
> pred 'z'
'y'
> succ 'z'
'{'

> fromEnum 'z'
122 - ascii code
> toEnum 122 :: Char
'z'

class Bounded a where
	minBound, maxBound
	
> succ False 
True
> succ True
max ...

> minBound :: Bool
False
> maxBound :: Bool 
True


>minBound :: Int
-9223372036854775808 - 64bit platform 


> maxBound :: Integer 
error (Integer - –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ç–∏–ø, –Ω–µ—Ç –≥—Ä–∞–Ω–∏—Ü) 


–ø—Ä–æ –∫–ª–∞—Å—Å —Ç–∏–ø–æ–≤ Num

module Demo where

class Num a where
	(+), (-), (*) :: a -> a -> a //–¥–µ–ª–µ–Ω–∏–µ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ, –æ–Ω–æ –≤—Å–µ –≤ –Ω–∞—Å–ª–µ–¥–Ω–∏–∫–∞—Ö —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –∏ —É –≤—Å–µ—Ö –ø–æ-—Ä–∞–∑–Ω–æ–º—É
	negate :: a -> a
	abs :: a -> a
	signum :: a -> a
	fromInteger :: Integer -> a
	
	x - y = x + negate y
	negate x = 0 - x
	
{-LAW    abs x * signum x == x -}


> :i Fractional - Num —Å –¥–µ–ª–µ–Ω–∏–µ–º
> :i RealFrac - –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ


avg :: Int -> Int -> Int -> Double
avg x y z = (fromInteger (toInteger x + toInteger y + toInteger z)) /  3.0



2.5 –ù–µ—Å—Ç—Ä–æ–≥–∞—è —Å–µ–º–∞–Ω—Ç–∏–∫–∞ ü§ØÔ∏è

–ù–µ—Ç –ø–æ—Ä—è–¥–∫–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π, —Ç–∫ –Ω–µ—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π

–†–µ–¥—É–∫—Ü–∏—è –≤—ã—á–∏—Å–ª–µ–Ω–∏–π
module Demo where

sumIt :: Int -> Int -> Int
sumIt x y = x + y

> sumIt (1 + 2) 3
6
2 —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ —ç—Ç–æ–≥–æ –¥–æ—Å—Ç–∏—á—å - –ª–µ–Ω–∏–≤–∞—è –∏ —ç–Ω–µ—Ä–≥–∏—á–Ω–∞—è

{-
–ª–µ–Ω–∏–≤–∞—è 
sumIt (2 + 3) 4 - 2 redex-—Å–∞
(2 + 3) 4
5 + 4
9

—ç–Ω–µ—Ä–≥–∏—á–Ω–∞—è
sumIt (2 + 3) 4
sumIt 5 4
5 + 4
9
-}

redex - —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ –æ—Ç REDucible EXpression
–≤ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö —è–∑—ã–∫–∞—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç —Å—Ç–∞—Ç–µ–≥–∏–∏ –Ω–µ –∑–∞–≤–∏—Å–∏—Ç


add7 :: Int -> Int -> Int 
add7 x y = x + 7

{-
–ª–µ–Ω–∏–≤–∞—è (—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–µ–µ, –Ω–æ –Ω–µ –≤—Å–µ–≥–¥–∞, —Å–º —Å–ª–µ–¥ –ø—Ä–∏–º–µ—Ä)
add7 1 (2 + 3)
1 + 7
8

—ç–Ω–µ—Ä–≥–∏—á–Ω–∞—è
add7 1 (2 + 3)
add7 1 5
1 + 7
8
-}

dup :: Int -> (Int, Int)
dup x = (x, x)

{-
dup (2 + 3)
(2 + 3, 2 + 3)
(5, 2 + 3)
(5, 5)

dup (2 + 3)
dup 5
(5, 5)
-}

–µ—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑, —Ç–æ —ç–Ω–µ—Ä–≥–∏—á–Ω–∞—è –≤—ã–≥–æ–¥–Ω–µ–µ, –µ—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç—Å—è, —Ç–æ –ª–µ–Ω–∏–≤–∞—è

dup (2 + 3)
(p, p) //p = 2 + 3 = 5 - —É–º–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è, –≤—ã–≥–æ–¥–Ω–µ–µ, —Ç–∫ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è 1 —Ä–∞–∑ 
(5, p)
(5, 5)


~> value = bar (3 * 10) (3 * 10) ((3 * 10) + (5 - 2))
~> value = (3 * 10) + (3 * 10)
~> value = 30 + 30
~> value = 60


module Demo where

const42 :: a -> Int
const42 = const 42

> const42 True
42
> const42 undefined -> –Ω–µ –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω–æ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ (—ç—Ç–æ –Ω–µ—Å—Ç—Ä–æ–≥–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏)
42

—Å—Ç—Ä–æ–≥–∞—è —Ñ—É–Ω–∫—Ü–∏—è - —Ä–∞—Å—Ö–æ–¥—è—â–∏–π—Å—è –∞—Ä–≥—É–º–µ–Ω—Ç -> —Ä–∞—Å—Ö–æ–¥—è—â–µ–µ—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ
–µ—Å—Ç—å –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä —Å—Ç—Ä–æ–≥–æ—Å—Ç–∏ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –º–æ–∂–µ—Ç –∑–∞–º–µ–Ω–∏—Ç—å –ª–µ–Ω–∏–≤—ã–µ/—ç–Ω–µ—Ä–≥–∏—á–Ω—ã–µ

—Å–ª–∞–±–∞—è –≥–æ–ª–æ–≤–Ω–∞—è (–∑–∞–≥–æ–ª–æ–≤–æ—á–Ω–∞—è) –Ω–æ—Ä–º–∞–ª—å–Ω–∞—è —Ñ–æ—Ä–º–∞ (WHNF)

{-
NF - normal form (–Ω–µ—Ç —Ä–µ–¥–µ–∫—Å–æ–≤)
42
(3, 4)
\x -> x + 2


–Ω–µ NF
"Real" ++ "world"
sin (pi / 2)
(\x -> x + 2) 5 - –ª—è–º–±–¥–∞-—Ñ—É–Ω–∫—Ü–∏—è, –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω–∞—è –∫ 5
(3, 1 + 5)

WHNF
\x -> x + 2*3 (–≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ —Ç–µ–ª–∞ –ª—è–º–±–¥–∞-—Ñ—É–Ω–∫—Ü–∏–∏)
(3, 1 + 5) - –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –¥–∞–Ω–Ω—ã—Ö –ø–∞—Ä—ã
(, 4*5) - —á–∞—Å—Ç–∏—á–Ω–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω—ã–π –∫–æ–Ω—Å—Ç—É–∫—Ç–æ—Ä –ø–∞—Ä—ã aka (,) (4*5)
(+) (7^2) - –≤—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è —á–∞—Å—Ç–∏—á–Ω–æ-–ø—Ä–∏–º–µ–Ω–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è (–µ—Å–ª–∏ –±—ã —Å–∞–º–∏ —Ñ—É–Ω–∫—Ü–∏—é –Ω–∞–ø–∏—Å–∞–ª–∏, –∞ –Ω–µ +, —Ç–æ –Ω–µ —Å—á–∏—Ç–∞–ª–æ—Å—å –±—ã)
-}


–µ—Å—Ç—å –ø—Ä–æ–±–ª–µ–º—ã —Å –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–π —Ü–µ–ø–æ—á–∫–æ–π –≤—ã—á–∏—Å–ª–µ–Ω–∏–π

seq -–æ–ø–µ—Ä–∞—Ç–æ—Ä, –Ω–∞—Ä—É—à–∞—é—â–∏–π –ª–µ–Ω–∏–≤—É—é —Å–µ–º–∞–Ω—Ç–∏–∫—É –∏ –∑–∞—Å—Ç–∞–≤–ª—è—é—â–∏–π –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—å —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–≤—à–∏–µ—Å—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è 

{-
seq :: a -> b -> b
seq _|_ b =_|_  - "–æ—Å–Ω–æ–≤–∞–Ω–∏–µ", –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ —Ä–∞—Å—Ö–æ–¥—è—â–∏—Ö—Å—è –≤—ã—á–∏—Å–ª–µ–Ω–∏–π
seq a b = b
-}


> seq 1 2
2
> seq undefined 2 
exception

> seq (undef, undef) 2
2 - –ø–æ—Å—Ç—Ä–æ–∏–ª –ø–∞—Ä—É, –∞ –µ–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏ –Ω–µ –ø–æ–∏–Ω—Ç–µ—Ä–µ—Å–æ–≤–∞–ª—Å—è

> seq (\x -> undef) 2
2 //–ª—è–º–±–¥–∞ —É–∂–µ –≤ whnf

seq —Ñ–æ—Ä—Å–∏—Ä—É–µ—Ç —Ç–æ–ª—å–∫–æ –¥–æ WHNF

($!) :: (a -> b) -> a -> b
f $! x = x `seq` f x //seq –∫–∞–∫ –æ–ø–µ—Ä–∞—Ç–æ—Ä –Ω–∞ –¥–≤—É—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–∞—Ö –∑–¥–µ—Å—å –∞–∫–∞ seq x f
x –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –¥–æ —Å–ª–∞–±–æ–π —Ñ–æ—Ä–º—ã –ø–µ—Ä–µ–¥ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º f –∫ –Ω–µ–º—É

> const 42 indefined
42
> const 42 $ undef 
42
> const 42 $! undef
exception

—ç—Ç–æ—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –Ω–µ –æ—Ç–∫–ª–∞–¥—ã–≤–∞–ª–∏—Å—å –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è

factorial n 
	| n >= 0 	= helper 1 n
	| otherwise 	= error "arg must be >= 0"
 where
  helper acc 0 = acc
  helper acc n = helper (acc * n) (n - 1)
  
  
2.6 –ú–æ–¥—É–ª–∏ –∏ –∫–æ–º–ø–∏–ª—è—Ü–∏—è ü§ØÔ∏è

–ò–º—è —Ñ–∞–π–ª–∞ –¥–æ–ª–∂–Ω–æ —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å –∏–º–µ–Ω–µ–º –º–æ–¥—É–ª—è –≤ —ç—Ç–æ–º —Ñ–∞–π–ª–µ. –í—Å–µ –º–æ–¥—É–ª–∏ —Å –±–æ–ª—å—à–æ–π –±—É–∫–≤—ã

module Demo where

import Data.Char (toUpper, toLower) //–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
import Data.Char hiding (toLower) //–≤—Å–µ –∫—Ä–æ–º–µ –æ–¥–Ω–æ–π


import Data.List
import Data.Set

> :t union 
error, —Ç–∫ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≤ –æ–±–æ–∏—Ö –º–æ–¥—É–ª—è—Ö

import Data.List
import qualified Data.Set

> :t union 
ok //–±—É–¥–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å—Å—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å Data.Set.union 
 
import Data.List 
import qualified Data.Set as Set

module Test (sumIt) where //–ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ —Ç–µ—Å—Ç–∞ –±—É–¥–µ—Ç —Ç–æ–ª—å–∫–æ —É–∫–∞–∑–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞

sumIt x y = x + y

const42 = const 42


module Demo where

import Test

f1 = const42 True

f2 = sumIt 3 4

–∏–Ω–∫–∞–ø—Å—É–ª—è—Ü–∏—è –Ω–∞ —É—Ä–æ–≤–Ω–µ –º–æ–¥—É–ª–µ–π —Ç–æ–ª—å–∫–æ –º–æ–∂–µ—Ç –±—ã—Ç—å (—Å–æ–∫—Ä—ã—Ç–∏–µ, –∫–∞–∫ –ø—Ä–∏–≤–∞—Ç—ã –≤ —Å++)


–∫–æ–º–ø–∏–ª—è—Ü–∏—è –≤ —Ö–∞—Å–∫–µ–ª–µ
1.—Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–π —Ä–∞–∑–±–æ—Ä, –≤—Å–µ –∏–º–µ–Ω–∞ –¥–µ–ª–∞—é—Ç—Å—è –∫–≤–∞–ª–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏
2.–ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤
3.—Ä–∞—Å—Å–∞—Ö–∞—Ä–∏–≤–∞–Ω–∏–µ - –ø–µ—Ä–µ–≤–æ–¥ —Ö–∞—Å–∫–µ–ª–ª–∞ –Ω–∞ core —è–∑—ã–∫
4.–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
5.–∫–æ–¥–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ stg -> c-- -> –Ω–∞—Å—Ç–æ—è—â–∏–π –∫–æ–¥–≥–µ–Ω


3.2 –§—É–Ω–∫—Ü–∏–∏ –≤—ã—Å—à–∏—Ö –ø–æ—Ä—è–¥–∫–æ–≤ –Ω–∞–¥ —Å–ø–∏—Å–∫–∞–º–∏ ü§ØÔ∏è

import Prelude hiding (filter, takeWhile, dropWhile, span, break)

filter :: (a -> Bool) -> [a] -> [a] //—É–Ω–∞—Ä–Ω—ã–π –ø—Ä–µ–¥–∏–∫–∞—Ç –Ω–∞ –≤—Ö–æ–¥–µ
filter p [] = []
filter p (x:xs)
	| p x		= x : filter p xs //—Ç—É—Ç p x —Ç–∏–ø–∞ true
	| otherwise 	= filter p xs

> filter (< 3) [1,2,3,4,1,2]
[1,2, 1,2]


takeWhile :: (a -> Bool) -> [a] -> [a] //—É–Ω–∞—Ä–Ω—ã–π –ø—Ä–µ–¥–∏–∫–∞—Ç –Ω–∞ –≤—Ö–æ–¥–µ
takeWhile _ [] = []
takeWhile p (x:xs)
	| p x		= x : takeWhile p xs //—Ç—É—Ç p x —Ç–∏–ø–∞ true
	| otherwise 	= []
	
> takeWhile (< 3) [1,2,3,4,1,2]
[1,2]

dropWhile :: (a -> Bool) -> [a] -> [a] //—É–Ω–∞—Ä–Ω—ã–π –ø—Ä–µ–¥–∏–∫–∞—Ç –Ω–∞ –≤—Ö–æ–¥–µ
dropWhile _ [] = []
dropWhile p xs@(x:xs') //—Å–∏–Ω–æ–Ω–∏–º
	| p x		= dropWhile p xs' //—Ç—É—Ç p x —Ç–∏–ø–∞ true
	| otherwise 	= xs
	
> dropWhile (< 3) [1,2,3,4,1,2]
[3,4,1,2]

–º–æ–≥–ª–∏ –±—ã –Ω–∞–ø–∏—Å–∞—Ç—å —Ç–∞–∫, —Ç–æ –∂–µ —Å–∞–º–æ–µ, –Ω–æ –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è —Å–±–æ—Ä–∫–∏ —Å–ø–∏—Å–∫–∞, –ø–æ—ç—Ç–æ–º—É –≤–≤–æ–¥–∏—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω—ã–π –ø—Å–µ–≤–¥–æ–Ω–∏–º –∫–∞–∫ –≤—ã—à–µ
dropWhile :: (a -> Bool) -> [a] -> [a] //—É–Ω–∞—Ä–Ω—ã–π –ø—Ä–µ–¥–∏–∫–∞—Ç –Ω–∞ –≤—Ö–æ–¥–µ
dropWhile _ [] = []
dropWhile p x:xs' //—Å–∏–Ω–æ–Ω–∏–º
	| p x		= dropWhile p xs' //—Ç—É—Ç p x —Ç–∏–ø–∞ true
	| otherwise 	= x:xs'
	
–ª–æ–∫–∞–ª—å–Ω—ã–π –ø—Å–µ–≤–¥–æ–Ω–∏–º –¥–∞–µ—Ç —Å–ª–æ–∂–Ω–æ–º—É –æ–±—Ä–∞–∑—Ü—É –∫–æ—Ä–æ—Ç–∫–æ–µ –∏–º—è
	
span :: (a -> Bool) -> [a] -> ([a],[a])
span p xs = (takeWhile p xs, dropWhile p xs)

break :: (a -> Bool) -> [a] -> ([a],[a]) 
break p = span (not . p)
—Ä–∞–∑—Ä—ã–≤ –∏ –≤ —Å–ø–∞–Ω–µ, –∏ –≤ –±—Ä–µ–π–∫–µ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –Ω–µ–≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ —É—Å–ª–æ–≤–∏—è

> span (< 3) [1,2,3,4,1,2] //–ø–æ–∫–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è - –≤ –ø–µ—Ä–≤—ã–π
([1,2],[3,4,1,2])
> break (> 3) [1,2,3,4,1,2] //–ø–æ–∫–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è - –≤ –ø–µ—Ä–≤—ã–π
([1,2,3],[4,1,2])


import Data.Char (isDigit)
readDigits :: String -> (String, String)
readDigits = span (isDigit)


import Data.List
filterDisj :: (a -> Bool) -> (a -> Bool) -> [a] -> [a]
filterDisj p1 p2 [] = []
filterDisj p1 p2 (x:xs)
	| (p1 x) || (p2 x)		= x : filterDisj p1 p2 xs
	| otherwise 	        = filterDisj p1 p2 xs
	
	
	
map - –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é –∏ —Å–ø–∏—Å–æ–∫, —Ñ—É–Ω–∫—Ü–∏—è –¥–µ–ª–∞–µ—Ç —á—Ç–æ-—Ç–æ –Ω–∞–¥ –∫–∞–∂–¥—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º —Å–ø–∏—Å–∫–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫

> map (+10) [1,2,3,4]
[11,12,13,14]

module Demo where

import Prelude hiding (map, concat, concatMap)

map :: (a -> b) -> [a] -> [b]
map _ []	= []
map f (x:xs) 	= f x : map f xs

concat - –æ–±–æ–±—â–µ–Ω–∏–µ ++ –Ω–∞ –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–≤–æ —Å–ø–∏—Å–∫–æ–≤

concatMap :: (a -> [b]) -> [a] -> [b]
concatMap f = concat . map f 

//concatMap f xs = concat (map f xs)

concatMap (\x -> [x*x, x*x*x]) [3,4,5]



import Prelude hiding (and, or, all, any)
and, or :: [Bool] -> Bool

and [] 	   = True
and (x:xs) = x && and xs

or []		= False
or (x:xs)	= x || or xs

all - –≤—ã—Å—à–∏–π –ø–æ—Ä—è–¥–æ–∫
all :: (a -> Bool) -> [a] -> Bool //—É–Ω–∞—Ä–Ω—ã–π –ø—Ä–µ–¥–∏–∫–∞—Ç –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º —Å–ø–∏—Å–∫–∞
all p = and . map p

> all odd [1,3,43]
True

any :: (a -> Bool) -> [a] -> Bool //—É–Ω–∞—Ä–Ω—ã–π –ø—Ä–µ–¥–∏–∫–∞—Ç –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º —Å–ø–∏—Å–∫–∞
any p = or . map p

words - —Å—Ç—Ä–æ–∫–∞ –≤ —Å–ø–∏—Å–æ–∫ –ø–æ —Å–ª–æ–≤–∞–º
unwords - –æ–±—Ä–∞—Ç–Ω–æ

revWords = unwords . map reverse . words


module Demo where

import Data.Char
delAllUpper :: String -> String
delAllUpper = unwords . filter (not . all isUpper) . words

zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] 
zipWith _ [] _	= []
zipWith _ _ []	= []
zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys

zipWith3 —Ç–æ –∂–µ —Å–∞–º–æ–µ, —Ç–æ–ª—å–∫–æ —Å —Ç—Ä–µ–º—è —Å–ø–∏—Å–∫–∞–º–∏


max3 :: Ord a => [a] -> [a] -> [a] -> [a]
max3 a b c = 
    let
        max3' p1 p2 p3 = max (max p1 p2) p3
    in
        zipWith3 max3' a b c
        
        
3.3 –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã —Å–ø–∏—Å–∫–æ–≤ ü§ØÔ∏è

–ö–∞–∫ –±–æ—Ä–æ—Ç—å—Å—è —Å —Ä–∞—Å—Ö–æ–¥–∏–º–æ—Å—Ç—è–º–∏?

> let bot = not bot
> bot
–∑–∞–≤–∏—Å–∞–µ—Ç

> let ones = 1 : ones - –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Å–ø–∏—Å–æ–∫ –µ–¥–∏–Ω–∏—Ü
> let nats n = n : nats (n + 1)
> take 10 $ nats 5
> head $ nats 42
42


> let squares = map (^2) & nats 1 - –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª


–†–µ–∞–ª–∏–∑—É–π—Ç–µ c –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ zipWith —Ñ—É–Ω–∫—Ü–∏—é fibStream, –≤–æ–∑–≤—Ä–∞—â–∞—é—â—É—é –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Å–ø–∏—Å–æ–∫ —á–∏—Å–µ–ª –§–∏–±–æ–Ω–∞—á—á–∏.

GHCi> take 10 $ fibStream
[0,1,1,2,3,5,8,13,21,34]

comment: –ü–æ–¥—Å–∫–∞–∑–∫–∞ - –æ–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –µ—Å–ª–∏ –≤—ã –≤–æ–∑—å–º–µ—Ç–µ –ª–∏—Å—Ç —Å —á–∏—Å–ª–∞–º–∏ –§–∏–±–±–æ–Ω–∞—á–∏ –∏ —Å–ª–æ–∂–∏—Ç–µ –µ–≥–æ —Å —Ç–µ–º –∂–µ –ª–∏—Å—Ç–æ–º, —É –∫–æ—Ç–æ—Ä–æ–≥–æ –≤—ã–∫–∏–Ω—É—Ç–∞ –≥–æ–ª–æ–≤–∞, –≤—ã –ø–æ–ª—É—á–∏—Ç–µ —Å–Ω–æ–≤–∞ –ª–∏—Å—Ç —á–∏—Å–µ–ª –§–∏–±–±–æ–Ω–∞—á–∏

fibStream :: [Integer]
fibStream = [0,1] ++ zipWith (+) fibStream (tail fibStream)


module Demo where

import Prelude hiding (repeat,replicate,cycle,iterate)

repeat :: a -> [a]
repeat x = xs where xs = x : xs

> take 5 $ repeat 'z'
"zzzzz"

replicate –∫–∞–∫ –≤—ã—à–µ, –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö —á–∏—Å–ª–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π

> take 10 $ cycle [1,2,3]
[1,2,3,1,2,3,1,2,3,1]

> take 5 $ iterate (^2) 2
[2,4,16,256,65536]

–ê—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
> [1..10]
[1,2,3,4,5,6,7,8,9,10]

enumFromTo 1 10
> [1,3..10]
[1,3,5,7,9]
enumFromThenTo

–°–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–π —Å–∞—Ö–∞—Ä

> [1..]
> take 5 $ enumFrom 1
[1,2,3,4,5]


> let xs = [1..20]
> [ x^2 | x <- xs] // –≤—Å–µ —Ö –≤ xs –±—É–¥—É—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å—Å—è —Ñ—É–Ω–∫—Ü–∏–µ–π —Å–ª–µ–≤–∞
> [ x^2 | x <- xs, x^2 < 200]
> [(x,y) | x <- [1,2], y <- [1,2]]
[(1,1), (1,2), (2,1), (2,2)]

–ø–æ–∏—Å–∫ –ø–∏—Ñ–∞–≥–æ—Ä–æ–≤—ã—Ö —Ç—Ä–æ–µ–∫
> [(x,y,z) | x <- xs, y <- xs, z <- xs, x^2 + y^2 == z^2, x <= y] //–ø–æ—Å–ª–µ–¥–Ω–µ–µ —É—Å–ª–æ–≤–∏–µ —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π


coins - —Å–ø–∏—Å–æ–∫

change n = [[x,y,z] | x <- coins, y <- coins, z <- coins, x + y + z = n]
change 





4. –¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö ü§ØÔ∏è
4.1 –¢–∏–ø—ã –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π ü§ØÔ∏è

data Bool = True | False //Bool - —Ç–∏–ø (–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Ç–∏–ø–∞), True, F - –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã –¥–∞–Ω–Ω—ã—Ö

not' :: B -> B deriving Show (deriving Show –¥–ª—è –≤—ã–≤–æ–¥–∞ —Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –≤ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä–µ) –º–æ–∂–Ω–æ Show, Eq, Read, Enum
not' T = F
not' F = T

–ú–æ–∂–Ω–æ –∑–∞–¥–∞—Ç—å —á–∞—Å—Ç–∏—á–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ, —É–±—Ä–∞–≤, –Ω–∞–ø—Ä–∏–º–µ—Ä, not' F = T. –¢–æ–≥–¥–∞ –Ω–∞–¥–æ –∑–∞–¥–∞—Ç—å –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É —É—Å–ª–æ–≤–∏–µ, —á—Ç–æ–±—ã –æ–Ω –≤—ã–∫–∏–¥—ã–≤–∞–ª warning –Ω–∞ —ç—Ç–æ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥—É–ª—è
:set -fwarn-incomplete-patterns


intToChar :: Int -> Char
intToChar 0 = '0'
...
intToChar _ = 'N'


isz :: Char -> Bool
isz 'z' = True
isz _ = False

stringToBool :: String -> Bool
stringToBool "true" = True
stringToBool "false" = False

data Color = Red | Green | Blue deriving Read

stringToColor :: String -> Color
stringToColor = read

–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å –æ–±—Ä–∞–∑—Ü–æ–º —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑ —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ
3 –≤–∞—Ä–∏–∞–Ω—Ç–∞: 
succ
fail
undefined (—Ä–∞—Å—Ö–æ–¥–∏–º–æ—Å—Ç—å)

foo 1 2 = 3
foo 0 _ = 5

> foo 0 undefined 
5 

> foo undefined 5
exception

–∏–Ω–æ–≥–¥–∞ –Ω—É–∂–Ω–æ —Å–æ–ø–æ—Å—Ç —Å –æ–±—Ä–∞–∑—Ü–æ–º –≤ –ø—Ä–∞–≤–æ–π —á–∞—Å—Ç–∏ –ø–æ—Å–ª–µ —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç—å

data LogLevel = Error | Warning | Info

cmp :: LogLevel -> LogLevel -> Ordering
cmp Error Error = EQ
cmp Warning Warning = EQ
cmp Info Info = EQ
cmp Error _ = GT
cmp Info _ = LT
cmp Warning Info = GT
cmp Warning Error = LT 

lessThanError :: LogLevel -> Bool
lessThanError lvl = 
	case cmp lvl Error of
	  LT -> True
	  _ -> False
	 
cmp lvl Error - –≤—ã—Ä–∞–∂–µ–Ω–∏–µ —Ç–∏–ø–∞ Ordering	 
	 
processData :: SomeData -> String
processData tmp = 
    case snd (doSomeWork tmp) of 
        0 -> "Success"
        errno -> "Fail: " ++ show errno
        
        
4.2 –¢–∏–ø—ã –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–π –∏ —Å—É–º–º –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–π ü§ØÔ∏è

data Point = Pt Double Double - –æ–¥–∏–Ω –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –¥–∞–Ω–Ω—ã—Ö —Ç–∏–ø–∞ Point

origin :: Point
origin = Pt 0.0 0.0

distanceToOrigin :: Point -> Double
distanceToOrigin (Pt x y) = sqrt (x ^ 2 + y ^ 2) - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å –æ–±—Ä–∞–∑—Ü–æ–º
Pt –º–æ–∂–Ω–æ –Ω–∞–∑–≤–∞—Ç—å Point, –Ω–∏–∫–∞–∫–∏—Ö –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –Ω–µ –±—É–¥–µ—Ç

rootsOld :: Double -> Double -> Double -> (Double, Double)
rootsOld a b c = (x1, x2) where
	x1 = helper (-d)
	x2 = hepler d
	helper x = (-b + x) / (2 * a)
	d = sqrt discr 
	discr = b ^ 2 - 4 * a * c
	
–ø—Ä–æ –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–æ—Ä–Ω–∏
data Roots = Roots Double Double | None - —Ç–∏–ø, —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç–æ–º None. –¢–∞–∫–∞—è –∑–∞–ø–∏—Å—å –∏–∑–æ–º–æ—Ä—Ñ–Ω–∞ –ø–∞—Ä–∞–º (D, D). –≠—Ç–æ—Ç —Ç–∏–ø –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ç–∏–ø–æ–º —Å—É–º–º –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–π
	deriving Show
roots :: Double -> Double -> Double -> Roots

roots a b c 
	| discr >= 0 = Roots x1 x2
	| otherwise = None
	where
	 x1 = helper (-d)
	 x2 = hepler d
	 helper x = (-b + x) / (2 * a)
	 d = sqrt discr 
	 discr = b ^ 2 - 4 * a * c

data Result' = Fail' Int | Success' Result

instance Show Result' where
    show (Fail' errno) = "Fail: " ++ show errno
    show (Success' Success) = "Success"

doSomeWork' :: SomeData -> Result'
doSomeWork' tmp = case snd (doSomeWork tmp) of 
                                                0 -> Success' Success
                                                errno -> Fail' errno


–º–æ–∂–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –¥–æ–ø —Ñ—É–Ω–∫—Ü–∏—é –∫–∞–∫ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –¥–∞–Ω–Ω—ã—Ö

data Shape = Circle Double | Rectangle Double Double
	deriving Show

square :: Double -> Shape - —Ñ—É–Ω–∫—Ü–∏—è square —Ç—É—Ç –∫–∞–∫ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
square a = Rectangle a a 

isSquare :: Shape -> Bool
isSquare (square _) = True - —Ç–∞–∫ –ø–∏—Å–∞—Ç—å –Ω–µ–ª—å–∑—è! –Ω—É–∂–µ–Ω –∏–º–µ–Ω–Ω–æ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∑–¥–µ—Å—å, –∞ –Ω–µ —Ñ—É–Ω–∫—Ü–∏—è
isSquare _          = False

–∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö

> import Data.Ratio
> 2 % 3 - –¥—Ä–æ–±—å
–Ω–∞—Å—Ç–æ—è—â–∏–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –¥—Ä—É–≥–æ–π, –Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –æ–ø–µ—Ä–∞—Ç–æ—Ä –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –≤–º–µ—Å—Ç–æ –Ω–µ–≥–æ, —á—Ç–æ–±—ã –±—ã–ª–æ —É–¥–æ–±–Ω–æ 


–Ω–µ–æ–ø—Ä–æ–≤–µ—Ä–∂–∏–º—ã–µ –æ–±—Ä–∞–∑—Ü—ã (–ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏–µ, —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π)
–ª–µ–Ω–∏–≤—ã–µ –æ–±—Ä–∞–∑—Ü—ã


4.3 –°–∏–Ω—Ç–∞–∫—Å–∏—Å –∑–∞–ø–∏—Å–µ–π

data Person = Person { firstName :: String, lastName :: String, age :: Int } deriving (Show, Eq)

–∞–Ω–∞–ª–æ–≥ —Ç–æ—á–∫–∏ –≤ –æ–æ–ø
infixl 1 &
x & f = f x

> john & age
33


4.4 –¢–∏–ø—ã —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏

data Coord a = Coord a a 

distance :: Coord Double -> Coord Double -> Double
distance (Coord x1 y1) (Coord x2 y2) = sqrt ((x1 - x2)^2 + (y1 - y2)^2)

manhDistance :: Coord Int -> Coord Int -> Int
manhDistance (Coord x1 y1) (Coord x2 y2) = abs (x1 - x2) + abs (y1 - y2)

twice :: a -> [a] = a -> [] a

> :kind Int 
*

> :k Maybe
* -> * 
kind –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ—Ç –∞—Ä–Ω–æ—Å—Ç—å


5. –ú–æ–Ω–∞–¥—ã

f :: a -> m b
—Å—Ç—Ä–µ–ª–∫–∞ –ö–ª–µ–π—Å–ª–∏











  

 




	



























 











	     





































    











































