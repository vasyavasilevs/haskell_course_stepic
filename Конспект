1.1 Ð’Ð²ÐµÐ´ÐµÐ½Ð¸ÐµðŸ¤¯ï¸

ÐšÐ¾Ð¼Ð¿Ð¸Ð»ÑÑ‚Ð¾Ñ€ (Ðš) Ð¸ Ð¸Ð½Ñ‚ÐµÑ€Ð¿Ñ€ÐµÑ‚Ð°Ñ‚Ð¾Ñ€ (Ð˜ÐŸ)
hs Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ðµ
Ð¾Ñ‚ÑÑ‚ÑƒÐ¿Ñ‹ ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹
Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÐµÐ¼Ñ‹Ð¹ Ð² Ð¸Ð½Ñ‚ÐµÑ€Ð¿Ñ€ÐµÑ‚Ð°Ñ‚Ð¾Ñ€Ðµ (GHCi) Ñ„Ð°Ð¹Ð» Ð´Ð¾Ð»Ð¶ÐµÐ½ Ñ€Ð°ÑÐ¿Ð¾Ð»Ð°Ð³Ð°Ñ‚ÑŒÑÑ Ð² Ñ‚Ð¾Ð¹ Ð¶Ðµ Ð¿Ð°Ð¿ÐºÐµ

module Test where
sayHello = putStrLn "Hello"

Prelude> :load Test - Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð¼Ð¾Ð´ÑƒÐ»Ñ
:reload - Ð¿ÐµÑ€ÐµÐ·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð¼Ð¾Ð´ÑƒÐ»Ñ

1.2 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¸ðŸ¤¯ï¸

ÐœÐ¾Ð´ÐµÐ»ÑŒ Ð²Ñ‹Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ñ, ÑÑ€Ð°Ð²Ð½ÐµÐ½Ð¸Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ñ… Ð¸ Ð¸Ð¼Ð¿ÐµÑ€Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ñ… ÑÐ·Ñ‹ÐºÐ¾Ð² (Ð¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ ÑÑ‡ÐµÐ¹ÐºÐ¸ Ð¿Ð°Ð¼ÑÑ‚Ð¸)
Ð’ Ñ„ÑƒÐ½ÐºÑ† - Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð° - Ð²Ñ‹Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ, Ñ€ÐµÐ´ÑƒÐºÑ†Ð¸Ð¸ Ð´Ð¾ ÐºÐ¾Ð½Ñ†Ð° Ð²Ñ‹Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ð¹. Ð’Ñ‹Ñ‡Ð¸ÑÐ»Ð¸Ñ‚ÐµÐ»ÑŒ -
Ð²Ð½ÐµÑˆÐ½ÑÑ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð°
Ð’Ñ‹Ð·Ð¾Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð½Ðµ Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð² ÑÐºÐ¾Ð±ÐºÐ°Ñ…, ÑÐºÐ¾Ð±ÐºÐ¸ Ð´Ð»Ñ Ð³Ñ€ÑƒÐ¿Ð¿Ð¸Ñ€Ð¾Ð²ÐºÐ¸ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²
acos (cos pi)
ÐµÑÐ»Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¸Ñ… Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð², Ñ‚Ð¾ f x y
Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ñ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ð°ÑÑÐ¾Ñ†Ð¸Ð°Ñ‚Ð¸Ð²Ð½Ð° Ð²Ð»ÐµÐ²Ð¾ - (max 5) 42 = 42
(max 5) Ð±ÑƒÐ´ÐµÑ‚ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÐµÐ¹ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð°
3 + sin 42 
3 + (max 5) 42 - Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ð¾Ðµ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹

Ð¡Ð¸Ð½Ñ‚Ð°ÐºÑÐ¸Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÑÐºÐ¾Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸

sumSquares x y = x ^ 2 + y ^ 2
Ð¸Ð¼Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ñ Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¾Ð¹ Ð±ÑƒÐºÐ²Ñ‹, Ð±Ð¾Ð»ÑŒÑˆÐ°Ñ Ð´Ð»Ñ Ñ‚Ð¸Ð¿Ð¾Ð² Ð´Ð°Ð½Ð½Ñ‹Ñ…
rock'n'roll = 42  
Ð² Ð˜ÐŸ let func 
> func

ÑÐ²Ð¾Ð¹ÑÑ‚Ð²Ð¾ Ñ‡Ð¸ÑÑ‚Ð¾Ñ‚Ñ‹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ - Ð½Ð¸ÐºÐ°ÐºÐ¸Ðµ Ð´Ñ€ÑƒÐ³Ð¸Ðµ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸ ÐºÑ€Ð¾Ð¼Ðµ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ð½Ðµ Ð²Ð»Ð¸ÑÑŽÑ‚ Ð½Ð° Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ

let fortyTwo = 39 + 3 (always 42)
ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ? ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€

ÑƒÑÐ»Ð¾Ð²Ð½Ñ‹Ð¹ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€
ÑƒÑÐ»Ð¾Ð²Ð½Ð¾Ðµ Ð²Ñ‹Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ let f x = if x > 0 then 1 else (-1) -Ð¾Ð±ÑŠÐµÐºÑ‚Ñ‹ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ñ‚Ð¸Ð¿Ð° Ð´Ð¾Ð»Ð¶Ð½Ñ‹ ÑÑ‚Ð¾ÑÑ‚ÑŒ Ð¿Ð¾ÑÐ»Ðµ Ð·ÐµÐ½ Ð¸ ÐµÐ»Ñ
f 5 = 1
f (-5) = -1 - ÑÐºÐ¾Ð±ÐºÐ¸ Ð¸Ð¼ÐµÑŽÑ‚ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ

let g x = (if x > 0 then 1 else (-1)) + 3

Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ð¾Ð³Ð¾ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ 
let max5 x = max 5 x Ñ€Ð°Ð²Ð½Ð¾ÑÐ¸Ð»ÑŒÐ½Ð¾ max5' = max 5 - Ð±ÐµÑÑ‚Ð¾Ñ‡ÐµÑ‡Ð½Ñ‹Ð¹ ÑÑ‚Ð¸Ð»ÑŒ Ð¿Ñ€Ð¾Ð³Ð¸
let discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
let standardDiscount = discount 1000 5 (sum Ð½Ðµ ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ÑÑ)

1.3 ÐžÐ¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ‹ðŸ¤¯ï¸

max 6 7 - Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÑŽÑ‚ÑÑ Ð² Ð¿Ñ€ÐµÑ„Ð¸ÐºÑÐ½Ð¾Ð¼ ÑÑ‚Ð¸Ð»Ðµ
6 + 7 - Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ‹ - Ð² Ð¸Ð½Ñ„Ð¸ÐºÑÐ½Ð¾Ð¼

6 `max` 7 - Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð² Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð½Ð¾Ð¼ ÑÑ‚Ð¸Ð»Ðµ, Ð·Ð°ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð² Ð¾Ð±Ñ€Ð°Ñ‚Ð½Ñ‹Ðµ ÐºÐ°Ð²Ñ‹Ñ‡ÐºÐ¸
(+) 6 7 - Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾Ð¼ ÑÑ‚Ð¸Ð»Ðµ
Ð²ÑÐµ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ‹ Ð±Ð¸Ð½Ð°Ñ€Ð½Ñ‹Ðµ, Ð¿Ñ€Ð¸Ð½Ð¸Ð¼Ð°ÑŽÑ‚ 2 Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ, Ð¸ÑÐºÐ» - Ð¿ÐµÑ€ÐµÐ´ Ð¾Ñ‚Ñ€Ð¸Ñ†Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¼Ð¸ Ñ‡Ð¸ÑÐ»Ð°Ð¼Ð¸
Ð² ÑÑ‚Ð¾Ð¼ Ð½ÐµÑƒÐ´Ð¾Ð±ÑÑ‚Ð²Ð¾, Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ ÐºÐ¾Ð³Ð´Ð° Ð¾Ñ‚Ñ€Ð¸Ñ† Ñ‡Ð¸ÑÐ»Ð¾ Ð² Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸, Ñ‚Ð¾ ÐµÐ³Ð¾ Ð½Ð°Ð´Ð¾ Ð·Ð°ÐºÐ»ÑŽÑ‡Ð°Ñ‚ÑŒ Ð² ÑÐºÐ¾Ð±ÐºÐ¸, Ñ‚Ðº Ð¸Ð½Ð°Ñ‡Ðµ Ð±ÑƒÐ´ÐµÑ‚ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¼Ð¸Ð½ÑƒÑ Ñ‡Ð¸ÑÐ»Ð¾

Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð²
3 + 5 * 8 = 43
Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚ Ð¾Ñ‚ 0 Ð´Ð¾ 9 Ð¾Ð±Ð¾Ð·Ð½Ð°Ñ‡Ð°ÐµÑ‚ÑÑ, Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ - ÑÐ°Ð¼Ñ‹Ð¹ Ð²Ñ‹ÑÐ¾ÐºÐ¸Ð¹ (10)

Ð°ÑÑÐ¾Ñ†Ð¸Ð°Ñ‚Ð¸Ð²Ð½Ð¾ÑÑ‚ÑŒ
(3 - (9) - 5)
Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð²Ñ‹Ñ‡Ð¸Ñ‚Ð°Ð½Ð¸Ñ Ð»ÐµÐ²Ð¾-Ð°ÑÑÐ¾Ñ†Ð¸Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ð¹
ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð° infixl, infixr, infix (Ð½Ðµ Ñ…Ð¾Ñ‚Ð¸Ð¼ ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ Ð»ÐµÐ²Ð¾Ð¿Ñ€Ð°Ð²Ð¾), Ð¿Ð¾Ñ‚Ð¾Ð¼ ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚Ð° Ð¸ Ð¸Ð¼Ñ (Ð¾Ð±Ð¾Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ)

Ð¸Ð· ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ð¹ Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ¸
infixr 8 ^, `logBase` - Ð¿Ñ€Ð°Ð²Ð°Ñ Ð°ÑÑÐ¾Ñ†Ð¸Ð°Ñ‚Ð¸Ð²Ð½Ð¾ÑÑ‚ÑŒ, 8 ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚Ð°. Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð»Ð¾Ð³Ð±ÐµÐ¹Ð· ÐºÐ°Ðº Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ñ‚Ð°ÐºÐ°Ñ Ð¶Ðµ
infixl 7 *, /, `div`, `mod`
infixl 6 +, -
infix 4 ==, /=, >, >=, <, <=
ÐºÐ¾Ð³Ð´Ð° Ð½Ð¸Ñ‡ÐµÐ³Ð¾ Ð½Ðµ Ð·Ð°Ð´Ð°Ð½Ð¾, Ñ‚Ð¾ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ Ð°ÑÑÐ¾Ñ† Ð»ÐµÐ²Ð°Ñ, Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚ 9

Ð½ÐµÑ‚ Ð²ÑÑ‚Ñ€Ð¾ÐµÐ½Ð½Ñ‹Ñ… Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð², Ð²ÑÐµ Ð¾Ð½Ð¸ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ñ‹ Ð² ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ð¹ Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐµ
Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ°Ð¼Ð¾Ð¼Ñƒ Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ‹ Ð¸Ð· Ð½Ð°Ð±Ð¾Ñ€Ð° ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð² 
{! # $ % * + . / < = > ? @ \ ^ | - ~} - Ñ€Ð°Ð²Ð½Ð¾Ð·Ð½Ð°Ñ‡Ð½Ñ‹
Ð¼Ð¾Ð¶Ð½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ÐµÑ‰Ðµ :, Ð½Ð¾ Ð½Ðµ Ð² Ð½Ð°Ñ‡Ð°Ð»Ðµ ÑÐ¾Ð±ÑÑ‚Ð²ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°

module Demo where

infixl 6 *+*

a *+* b = a ^ 2 + b ^ 2 (Ñ€Ð°Ð²Ð½Ð¾ÑÐ¸Ð»ÑŒÐ½Ð¾ (*+*) a b = a ^ 2 + b ^ 2)

ÐµÐ³Ð¾ Ð¼Ð¾Ð¶Ð½Ð¾ Ð±Ñ‹Ð»Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð¸ Ð² Ð²Ð¸Ð´Ðµ 3 *+* 4 = 25 Ð¸ (*+*) 3 4

Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ð¾Ðµ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° Ðº Ð¾Ð´Ð½Ð¾Ð¼Ñƒ Ð¸Ð· ÑÐ²Ð¾Ð¸Ñ… Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²
(/) 2 ÑÐºÐ²Ð¸Ð² (2 /) - ÑÐµÑ‡ÐµÐ½Ð¸Ðµ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° (Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð°)
(2 /) 4 = 0.5 Ð´Ð²Ð° Ð´ÐµÐ»Ð¸Ñ‚ÑŒ Ð½Ð° 4 Ñ€Ð°Ð²Ð½Ð¾ 1/2
(/ 2) 4 = 2 Ñ‡ÐµÑ‚Ñ‹Ñ€Ðµ Ð´ÐµÐ»Ð¸Ñ‚ÑŒ Ð½Ð° Ð´Ð²Ð° Ñ€Ð°Ð²Ð½Ð¾ 2
Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹ ÑÐºÐ¾Ð±ÐºÐ¸
ÐµÑÑ‚ÑŒ Ð¸ÑÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ (- 2) - ÑÑ‚Ð¾ Ð½Ðµ ÑÐµÑ‡ÐµÐ½Ð¸Ðµ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° -, Ð° Ñ‡Ð¸ÑÐ»Ð¾ -2

Ð·Ð½Ð°Ñ‡Ð¾Ðº Ð¿Ñ€Ð¾Ð±ÐµÐ»Ð°
module Demo where

f $ x = f x
sin 0 = 0 ÑÐºÐ²Ð¸Ð² sin $ 0 = 0
Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð´Ð¾Ð»Ð»Ð°Ñ€ ÑÐ°Ð¼Ñ‹Ð¹ Ð½Ð¸Ð·ÐºÐ¸Ð¹ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚ Ð¸Ð¼ÐµÐµÑ‚, Ð¸Ð¼ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¾Ñ‚ ÑÐºÐ¾Ð±Ð¾Ðº Ð¸Ð·Ð±Ð°Ð²Ð»ÑÑ‚ÑŒÑÑ
sin (pi / 2) ÑÐºÐ²Ð¸Ð² sin $ pi / 2
Ñƒ Ð´Ð¾Ð»Ð»Ð°Ñ€Ð° Ð¿Ñ€Ð°Ð²Ð°Ñ Ð°ÑÑÐ¾Ñ†Ð¸Ð°Ñ‚Ð¸Ð²Ð½Ð¾ÑÑ‚ÑŒ

{--} - comment
{- f (g x (h y)) == f $ g x (h y) == f $ g x $ h y -}

logBase x $ y Ð¼ÐµÐ¶Ð´Ñƒ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð°Ð¼Ð¸ ÑÑ‚Ñƒ Ñ…Ñ€ÐµÐ½ÑŒ Ð½Ð°Ð´Ð¾ ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ........

Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ñ‚Ð¸Ð¿Ñ‹ðŸ¤¯ï¸

Ð¢Ð¸Ð¿Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ ÑÐ·Ñ‹Ðº ÑÐ¾ ÑÑ‚Ñ€Ð¾Ð³Ð¾Ð¹ (Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ Ð½ÐµÑÐ²Ð½Ð¾Ðµ Ð¿Ñ€Ð¸Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð¾Ð²) ÑÑ‚Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¾Ð¹ (Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ñ‚Ð¸Ð¿Ð¾Ð² Ð¿Ñ€Ð¾Ð¸ÑÑ…Ð¾Ð´Ð¸Ñ‚ Ð½Ðµ Ð²Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð¸ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ, Ð° Ð²Ð¾ Ð²Ñ€ÐµÐ¼Ñ ÐºÐ¾Ð¼Ð¿Ð¸Ð»ÑÑ†Ð¸Ð¸) ÑÐ¸ÑÑ‚ÐµÐ¼Ð¾Ð¹ Ñ‚Ð¸Ð¿Ð¸Ð·Ð°Ñ†Ð¸Ð¸

Ð²Ñ‹ÑÑÐ½ÐµÐ½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð¾Ð² - ÐºÐ¾Ð¼Ð°Ð½Ð´Ð° :type 
> :type 'c' 
'c' :: Char
'\n' is char too
> :type 'zz' - error
> :type True = Type :: Bool
> :t False -//-

ÐµÑÑ‚ÑŒ ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ñ‹Ð¹ Ð½Ð°Ð±Ð¾Ñ€ Ñ‚Ð¸Ð¿Ð¾Ð², common name Num
> :t 3
3 :: Num a => a

> let x = 3 :: Int

> :t 3.5
Fractional a => a

Function type is declared by binary operator - arrow (->) (infixr)
not False = True 
> :t not 
not :: Bool -> Bool

> (&&) False True (logical operator && in functional style, returns True if both of arguments are true)
False

> ((&&) False) True 
        |        |
    Bool func Bool item
eventually, type of && is Bool -> (Bool -> Bool) (input: Bool, output: func Bool -> Bool)
parentheses may be not mentioned, finally 
> :t (&&)
(&&) :: Bool -> Bool -> Bool
number of arguments the same as number of arrows

Ð¢Ð¸Ð¿ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð¼Ð¾Ð¶Ð½Ð¾ Ð·Ð°Ð´Ð°Ñ‚ÑŒ Ð² Ñ„Ð°Ð¹Ð»Ðµ Ð¸ÑÑ…Ð¾Ð´Ð½Ð¾Ð³Ð¾ ÐºÐ¾Ð´Ð° Ð²Ð¼ÐµÑÑ‚Ðµ Ñ ÐµÐµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸ÐµÐ¼:

discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum

ÐžÑ‚Ð¼ÐµÑ‚Ð¸Ð¼, Ñ‡Ñ‚Ð¾ Ð¾Ð±ÑŠÑÐ²Ð»ÐµÐ½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð° Ð½ÐµÐ¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾, Ñ…Ð¾Ñ‚Ñ Ñ‡Ð°ÑÑ‚Ð¾ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ÑÑ Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð°Ñ†Ð¸Ð¸. Ð•Ð³Ð¾ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾ Ñ€Ð°ÑÐ¿Ð¾Ð»Ð°Ð³Ð°ÑŽÑ‚ Ð¿ÐµÑ€ÐµÐ´ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸ÐµÐ¼ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸, Ñ…Ð¾Ñ‚Ñ ÑÑ‚Ð¾ Ð¾Ð±ÑŠÑÐ²Ð»ÐµÐ½Ð¸Ðµ Ð²ÐµÑ€Ñ…Ð½ÐµÐ³Ð¾ ÑƒÑ€Ð¾Ð²Ð½Ñ Ð¼Ð¾Ð¶Ð½Ð¾ Ñ€Ð°ÑÐ¿Ð¾Ð»Ð¾Ð¶Ð¸Ñ‚ÑŒ Ð² Ð»ÑŽÐ±Ð¾Ð¼ Ð¼ÐµÑÑ‚Ðµ Ñ„Ð°Ð¹Ð»Ð° Ñ Ð¸ÑÑ…Ð¾Ð´Ð½Ñ‹Ð¼ ÐºÐ¾Ð´Ð¾Ð¼

Ð½Ðµ Ð²ÑÐµ Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÑ‡Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹ Ñ‡ÐµÑ€ÐµÐ· ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½ÑƒÑŽ Ð¿Ñ€ÐµÐ»ÑŽÐ´Ð¸ÑŽ, Ð´Ð»Ñ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ñ… Ð½ÑƒÐ¶ÐµÐ½ Ð½Ð¾Ð²Ñ‹Ð¹ Ð¼Ð¾Ð´ÑƒÐ»ÑŒ Ð¸ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚ ÐµÐ³Ð¾

module Demo where

import Data.Char

test = isDigit '7'

output = True

import of module may be done in ghci directly

Ð ÐµÐ°Ð»Ð¸Ð·ÑƒÐ¹Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ twoDigits2Int, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ð¿Ñ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚ Ð´Ð²Ð° ÑÐ¸Ð¼Ð²Ð¾Ð»Ð° Ð¸ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ñ‡Ð¸ÑÐ»Ð¾, ÑÐ¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð½Ð¾Ðµ Ð¸Ð· ÑÑ‚Ð¸Ñ… ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð², ÐµÑÐ»Ð¸ Ð¾Ð±Ð° ÑÐ¸Ð¼Ð²Ð¾Ð»Ð° Ñ‡Ð¸ÑÐ»Ð¾Ð²Ñ‹Ðµ, Ð¸ 100 Ð² Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð½Ð¾Ð¼ ÑÐ»ÑƒÑ‡Ð°Ðµ. (ÐŸÐµÑ€Ð²Ñ‹Ð¹ ÑÐ¸Ð¼Ð²Ð¾Ð» Ñ€Ð°ÑÑÐ¼Ð°Ñ‚Ñ€Ð¸Ð²Ð°ÐµÑ‚ÑÑ ÐºÐ°Ðº ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð´ÐµÑÑÑ‚ÐºÐ¾Ð², Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ â€” ÐµÐ´Ð¸Ð½Ð¸Ñ†.)

import Data.Char
twoDigits2Int :: Char -> Char -> Int
twoDigits2Int x y = if isDigit x && isDigit y == True then digitToInt x * 10 + digitToInt y else 100 

ÐšÐ¾Ñ€Ñ‚ÐµÐ¶ - ÑƒÐ¿Ð¾Ñ€ÑÐ´Ð¾Ñ‡ÐµÐ½Ð½Ñ‹Ð¹ Ð½Ð°Ð±Ð¾Ñ€ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ñ„Ð¸ÐºÑÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð¹ Ð´Ð»Ð¸Ð½Ñ‹, Ñ‚Ð¸Ð¿ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ð¼Ð± Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð»ÑŒÐ½Ñ‹Ð¹
> (2, True) - 2-items kortege
(2, True) 
> fst (2, True)
2
> snd (2, True)
True
> :t ('x', True)
('x', True) :: (Char, Bool)

> (3) - one-element kortege does not exist! but exists empty kortege
> ()
()
> :t ()
() :: () 

Ð¡Ð¿Ð¸ÑÐºÐ¸ - ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð½Ñ‹Ðµ Ñ‚Ð¸Ð¿Ñ‹, Ð½Ð¾ ÐµÑÑ‚ÑŒ Ð´Ð²Ð° Ð¾Ñ‚Ð»Ð¸Ñ‡Ð¸Ñ Ð¾Ñ‚ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ÐµÐ¹:
1. Ð¡Ð¿Ð¸ÑÐºÐ¸ Ð³Ð¾Ð¼Ð¾Ð³ÐµÐ½Ð½Ñ‹ (ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸ Ð³ÐµÑ‚ÐµÑ€Ð¾Ð³ÐµÐ½Ð½Ñ‹) - Ð²ÑÐµ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹ ÑÐ¿Ð¸ÑÐºÐ° Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð¿Ñ€Ð¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°Ñ‚ÑŒ Ðº Ð¾Ð´Ð½Ð¾Ð¼Ñƒ Ñ‚Ð¸Ð¿Ñƒ
2. Ð”Ð»Ð¸Ð½Ð° ÑÐ¿Ð¸ÑÐºÐ° Ð½Ðµ Ñ„Ð¸ÐºÑÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð° Ð¸ Ð½Ðµ Ð¸Ð·Ð²ÐµÑÑ‚Ð½Ð° ÐºÐ¾Ð¼Ð¿Ð¸Ð»ÑÑ‚Ð¾Ñ€Ñƒ

> [1,2,3] - list of digits
> [False, True]
> :t [False, True]
[False, True] :: [Bool]
 
For char there is a special form of otput list - string
> ['H', 'i']
"Hi"
> "Hi" :: String


: - operator of adding one element at the head of a list
> let str = 'H' : "ello"
> str
"Hello"

++ - concatenation of two lists
> str ++ " world"
"Hello world"

1.5 Ð ÐµÐºÑƒÑ€ÑÐ¸Ñ ðŸ¤¯ï¸

Ð’ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ñ… ÑÐ·Ñ‹ÐºÐ°Ñ… Ð½ÐµÑ‚ Ð¿Ð¾Ð½ÑÑ‚Ð¸Ñ Ñ†Ð¸ÐºÐ»Ð¸Ñ‡ÐµÑÐºÐ¾Ð¹ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ Ð¸ Ñ†Ð¸ÐºÐ» Ð·Ð°Ð¼ÐµÐ½ÑÐµÑ‚ÑÑ Ñ€ÐµÐºÑƒÑ€ÑÐ¸ÐµÐ¹.

factorial n = if n == 0 then 1 else n * factorial (n - 1)

To avoid cycles we need 
1.to put not the same value of parameter in the right part of the func towards left part of the func (n =! n - 1)
2.terminate condition (if n == 0 then 1) reqursion interrupts


{-
factorial 2
 ~> if 2 == 0 then 1 else 2 * factorial 1
 ~> 2 * factorial 1
 ~> 2 * (if 1 == 0 then 1 else 1 * factorial 0)
 ~> 2 * 1 * factorial 0
 ~> 2 * factorial 0
 ~> 2 * (if 0 == 0 then 1 else 0 * factorial(-1))
 ~> 2 * 1
 ~> 2
-}

calculations are made directly in language

if-then-else is not comfortable enough for using, so exists comparement with origin: not alone equation

factorial' 0 = 1
factorial' n = n * factorial' (n - 1)

another description of parameters
n - irrefutable origin

reqursion from negative argument - fail
funcs error & indefined

> error "ABC" - outputs error message
*** Exception: ABC
> undefined - interrupts code immediately
*** Exception: Prelude.undefined 

undefined returns bottom symbol, it is used as an element of all types

adjusting
factorial'' 0 = 1
factorial'' n = if n < 0 then error "arg must be >= 0" else n * factorial'' (n - 1)

> factorial'' (-3) 
*** -/-

comparement with origin is not universal method, so there are guards
factorial''' 0 = 1
factorial''' n | n < 0 = error "arg must be >= 0" //guard 1
               | n > 0 = n * factorial''' (n - 1) //guard 2
bool
factorial4 n | n == 0		= 1
	     | n < 0 		= n * factorial''' (n - 1) 
             | otherwise 	= error "arg must be >= 0"

otherwise = True

we also may develop smth like loop by additional variable
factorial5 n | n >= 0 	= helper 1 n
	     | otherwise = error "arg must be >= 0"
	     
helper acc 0 = acc
helper acc n = helper (acc * n) (n - 1)

raise effectivity


1.6 Ð›Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ðµ ÑÐ²ÑÐ·Ñ‹Ð²Ð°Ð½Ð¸Ñ Ð¸ Ð¿Ñ€Ð°Ð²Ð¸Ð»Ð° Ð¾Ñ‚ÑÑ‚ÑƒÐ¿Ð¾Ð² ðŸ¤¯ï¸

Ð”Ð²ÑƒÐ¼ÐµÑ€Ð½Ñ‹Ð¹ ÑÐ¸Ð½Ñ‚Ð°ÐºÑÐ¸Ñ, Ñ€Ð°ÑÐ¿Ð¾Ð·Ð½Ð°ÑŽÑ‚ÑÑ ÐºÐ¾Ð¼Ð¿Ð¸Ð»ÑÑ‚Ð¾Ñ€Ð¾Ð¼
Ñ‚Ð°Ð± - 8 Ð¿Ñ€Ð¾Ð±ÐµÐ»Ð¾Ð²
ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¸Ðµ Ð¾Ñ‚ÑÑ‚ÑƒÐ¿Ð° Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾, ÑƒÐ¼ÐµÐ½ÑŒÑˆÐµÐ½Ð¸Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ñ€Ð¸Ð²ÐµÑÑ‚Ð¸ Ðº Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð°Ð¼

module Demo where

roots:: Double -> Double -> Double 
	-> (Double, Double) it is law-acceptable
roots a b c = 
  (
    (-b - sqrt (b^2 - 4 * a * c)) / (2 * a)
  ,
    (-b + sqrt (b^2 - 4 * a * c)) / (2 * a)
  )
  
null tab is global declaration
in a body of a func we can use any non-null tap

Ð² ÐºÐ¾Ð´Ðµ Ð²Ñ‹ÑˆÐµ ÐºÐ¾Ð¿Ð¸Ñ€ÑƒÐµÑ‚ÑÑ ÐºÐ¾Ñ€ÐµÐ½ÑŒ Ð¸Ð· Ð´Ð¸ÑÐºÑ€Ð¸Ð¼, Ñ…Ð¾Ñ‡ÐµÑ‚ÑÑ Ð·Ð°Ð²ÐµÑÑ‚Ð¸ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾-Ð¾Ð¿Ñ€ÐµÐ´ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½ Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ÐµÐµ (let in)


roots' a b c = 
    let d = sqrt (b^2 - 4 * a * c) in 
    ((-b - d) / (2 * a), (-b + d) / (2 * a))

//e.g. let k in f(k)

> let x = True in (True, x)
(True, True)

let in can declare multiple bindings

roots'' a b c = 
    let {d = sqrt (b^2 - 4 * a * c); x1 = (-b - d) / (2 * a); x2 = (-b + d) / (2 * a)} in 
    (x1, x2)
    
more comfortable is version of declaring with tabs instead of ;
roots''' a b c =
 let
    x1 = (-b - d) / aTwice
    x1 = (-b + d) / aTwice
    d = sqrt $ b^2 - 4 * a * c
    aTwice = 2 * a
 in (x1, x2)
 
local bindings must have the same size of tabs

also we can declare local functions

factorial5 n | n >= 0 	= helper 1 n
	     | otherwise = error "arg must be >= 0"
	     
helper acc 0 = acc
helper acc n = helper (acc * n) (n - 1)

factorial6 n 
	| n >= 0 = let
	    helper acc 0 = acc
	    helper acc n = helper (acc * n) (n - 1)
	  in helper 1 n
	| otherwise = error "arg must be >= 0"

also exists local binding of origins

rootsDiff a b c = let
   (x1, x2) = roots a b c
   in x2 - x1
   
(x2, x1) - origin (//aka local variable in other lang-s)

local bindings with 'where'
where^(-1) = let in

roots''' a b c =
 let
    x1 = (-b - d) / aTwice
    x1 = (-b + d) / aTwice
    d = sqrt $ b^2 - 4 * a * c
    aTwice = 2 * a
 in (x1, x2)
 
roots'''' a b c = (x1, x2) where
    x1 = (-b - d) / aTwice
    x2 = (-b + d) / aTwice
    d = sqrt $ b^2 - 4 * a * c
    aTwice = 2 * a
    
differency in properties 

> let x = 2 in x^2
4
> x^2 where x = 2 
does not work

factorial6 n 
	| n >= 0 = let
	    helper acc 0 = acc
	    helper acc n = helper (acc * n) (n - 1)
	  in helper 1 n
	| otherwise = error "arg must be >= 0"

factorial7 n 
	| n >= 0 	= helper 1 n
	| otherwise 	= error "arg must be >= 0"
 where
  helper acc 0 = acc
  helper acc n = helper (acc * n) (n - 1)
  
in factorial7 we can use helper in all guards



2.1 ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„Ð¸Ð·Ð¼ (1) ðŸ¤¯ï¸

Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¾Ð±Ð»Ð°Ð´Ð°ÐµÑ‚ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„Ð½Ñ‹Ð¼ Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸ÐµÐ¼, ÐµÑÐ»Ð¸ Ð¾Ð½Ð° Ð¼.Ð±. Ð²Ñ‹Ð·Ð²Ð°Ð½Ð° Ð½Ð° Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸ÑÑ… Ñ€Ð°Ð·Ð½Ñ‹Ñ… Ñ‚Ð¸Ð¿Ð¾Ð² (int + int, double + double, + Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„ÐµÐ½)

2 Ñ‚Ð¸Ð¿Ð°: Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ð¸ ÑÐ¿ÐµÑ†Ð¸Ð°Ð»ÑŒÐ½Ñ‹Ð¹

ÐŸÐ°Ñ€Ð°Ð¼: ÐºÐ¾Ð´ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð¾Ð´Ð¸Ð½Ð°ÐºÐ¾Ð² Ð´Ð»Ñ Ð²ÑÐµÑ… Ñ‚Ð¸Ð¿Ð¾Ð²

+ - ÑÐ¿ÐµÑ†Ð¸Ð°Ð»ÑŒÐ½Ñ‹Ð¹, Ð¿Ð¾Ñ‚Ð¾Ð¼Ñƒ Ñ‡Ñ‚Ð¾ Ñ‡Ð¸ÑÐ»Ð° Ð½Ð° Ð½Ð¸Ð·ÐºÐ¾Ð¼ ÑƒÑ€Ð¾Ð²Ð½Ðµ Ñ Ñ€Ð°Ð·Ð½Ñ‹Ð¼Ð¸ Ñ‚Ð¸Ð¿Ð°Ð¼Ð¸ (Ñ„Ð»Ð¾Ñ‚, Ð¸Ð½Ñ‚) ÑÐºÐ»Ð°Ð´Ñ‹Ð²Ð°ÑŽÑ‚ÑÑ Ð¿Ð¾-Ñ€Ð°Ð·Ð½Ð¾Ð¼Ñƒ

ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¸Ñ‡ÐµÑÐºÐ¸ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„Ð½Ð¾Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸
>let id x = x
>id :: t -> t //t - Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ð¹ Ñ‚Ð¸Ð¿, Ð»ÑŽÐ±Ð¾Ðµ Ð²Ð¼ÐµÑÑ‚Ð¾ Ð½ÐµÐ³Ð¾ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¿Ð¾ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ


>id id
> :t (id id) 
(t -> t) -> (t -> t) = t -> t


> let k x y = x
> k 42 True
42
> :t k
k :: t1 -> t -> t1
> :t const - ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ
a -> b -> a

> undefined //ÐºÐ¾Ð½ÑÑ‚Ð°Ð½Ñ‚Ð° ÑƒÐ½Ð¸Ð²ÐµÑ€ÑÐ°Ð»ÑŒÐ½Ð°Ñ, Ñ‚Ð¸Ð¿ Ð»ÑŽÐ±Ð¾Ð¹, Ð¿Ñ€ÐµÑ€Ñ‹Ð²Ð°ÐµÑ‚ Ð¸ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñ‹
*** exception

Ð¼Ð¾Ð¶ÐµÐ¼ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡Ð¸Ñ‚ÑŒ ÑÑ‚ÐµÐ¿ÐµÐ½ÑŒ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„Ð¸Ð·Ð¼Ð° Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸, ÑÐ²Ð½Ð¾ ÑƒÐºÐ°Ð·Ð°Ð² ÐµÐµ Ñ‚Ð¸Ð¿

mono :: Char -> Char //Ð¼Ð¾Ð½Ð¾Ð¼Ð¾Ñ€Ñ„Ð½Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ñ Ð±Ð¾Ð»ÐµÐµ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ð¼ Ñ‚Ð¸Ð¿Ð¾Ð¼, Ñ‡ÐµÐ¼ id
mono x = x


semiMono :: Char -> a -> Char //Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ð¾Ðµ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„Ð¸Ð·Ð¼Ð°
semiMono x y = x


Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð²Ñ‹ÑÑˆÐ¸Ñ… Ð¿Ð¾Ñ€ÑÐ´ÐºÐ¾Ð² - Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ð¿Ñ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚ Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð´Ñ€ÑƒÐ³ÑƒÑŽ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ, Ð¿Ñ€Ð¸Ð¼ÐµÑ€ Ð² ÑÐ¸ - qsort

> :t ($)
(a -> b) -> a -> b    //()-Ñ„Ñ†Ð¸Ñ, Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚ - Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÑÐµÑ‚ Ñ„Ñ†Ð¸ÑŽ Ðº Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ñƒ 

> :t apply2 f x = f (f x)
(t -> t) -> t -> t //Ð·Ð´ÐµÑÑŒ a Ð¸ b - Ð¾Ð´Ð½Ð¾ Ð¸ Ñ‚Ð¾ Ð¶Ðµ = t 

> apply2 (+5) 22
32
> apply (++ "AB") "CD"
"CDABAB"

flip f y x = f x y - standard lib

> flip (/) 4 2
0.5
> (/) 4 2
2

> flip const 5 True
True

ÐµÑÑ‚ÑŒ Ð°Ð½Ð¾Ð½Ð¸Ð¼Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸
> 2 * x + 7
error
>let f x = 2 * x + 7
> f 10
27

Ð°Ð»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ð° (Ð»ÑÐ¼Ð±Ð´Ð°-Ð²Ñ‹Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ)
> (\x -> 2 * x + 7) 10
27

> let f' = \x -> 2 * x + 7
> f' 10
27

> let lenVec x y = sqrt $ x^2 + y^2
> let lenVec = \x -> \y-> sqrt $ x^2 + y^2
> lenVec 3 4 
5
Ð¼Ð¾Ð¶Ð½Ð¾ ÐµÑ‰Ðµ Ñ‚Ð°Ðº 
> let lenVec = \x y -> sqrt $ x^2 + y^2

Ñ‡Ð°ÑÑ‚Ð¾ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÑÑŽÑ‚ÑÑ Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑÑ… Ð²Ñ‹ÑÑˆÐ¸Ñ… Ð¿Ð¾Ñ€ÑÐ´ÐºÐ¾Ð²

> let p1 = ((1,2), (3,4))
> let p2 = ((3,4), (5,6))
> fst $ fst p1
1


sumFstFst = (+) `on` helper
	where helper pp = fst $ fst pp
	

>sumFstFst p1 p2 
4 //ÑÐ»Ð¾Ð¶Ð¸Ð»Ð¸ÑÑŒ Ð¿ÐµÑ€Ð²Ñ‹Ðµ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹ Ð¿Ð°Ñ€

ÐÐž 
sumFstFst' = (+) `on` (\pp -> fst $ fst pp) - Ñ‚Ð°Ðº Ð³Ð¾Ñ€Ð°Ð·Ð´Ð¾ Ð»ÑƒÑ‡ÑˆÐµ


2.2 ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„Ð¸Ð·Ð¼ (2) ðŸ¤¯ï¸

f Ð¸ g, Ð½Ð°Ð´Ð¾ Ð½Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ ÐºÐ¾Ð¼Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸
> f :: b -> c
> g :: a -> b
> x :: a

> f (g x) :: c 
Ð½Ð°Ð¿Ð¸ÑˆÐµÐ¼ Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ, Ñ‚Ð¾ ÐµÑÑ‚ÑŒ Ð°Ð±ÑÑ‚Ñ€Ð°Ð³Ð¸Ñ€ÑƒÐµÐ¼ÑÑ Ð¿Ð¾ Ð¸ÐºÑÑƒ, Ñ‚Ð¾ ÐµÑÑ‚ÑŒ Ð½Ð°Ð¿Ð¸ÑˆÐµÐ¼ Ð»ÑÐ¼Ð±Ð´Ð°-Ð²Ñ‹Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ
ÑƒÑÐ»Ð¾Ð²Ð½Ð¾ h x = f (g x) - Ð¿ÐµÑ€ÐµÐ¼ÐµÑ‰Ð°ÐµÐ¼ Ð¸ÐºÑ Ð²Ð¿Ñ€Ð°Ð²Ð¾ Ð¸ ÑƒÐ±Ð¸Ñ€Ð°ÐµÐ¼ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ðµ Ð°Ñˆ
> \x -> f (g x) :: a -> c
> let compose f g = \x -> f (g x)
> :t compose
compose :: (t1 -> t) -> (t2 - t1) -> t2 -> t1 aka a b c

Ð² Ñ…Ð°ÑÐºÐµÐ»Ð»Ðµ ÑƒÐ¶Ðµ Ð¾Ð¿ÐµÑ€ÐµÐ´ÐµÐ»ÐµÐ½ Ñ‚Ð¸Ð¿ ÐºÐ¾Ð¼Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸ ÐºÐ°Ðº Ð²Ñ‹ÑˆÐµ:
> :i (.) // :i - info


Ð±Ñ‹Ð»Ð¾ Ñ€Ð°Ð½ÑŒÑˆÐµ:
sumFstFst' = (+) `on` (\pp -> fst $ fst pp) - Ñ‚Ð°Ðº Ð³Ð¾Ñ€Ð°Ð·Ð´Ð¾ Ð»ÑƒÑ‡ÑˆÐµ

sumFstFst'' = (+) `on` (fst . fst)

{-
Ð¦ÐµÐ¿Ð¾Ñ‡ÐºÐ° Ð¿Ð¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹ Ð¼.Ð±. Ð·Ð°Ð¼ÐµÐ½ÐµÐ½Ð° ÐºÐ¾Ð¼Ð¿Ð¾Ð·Ð¸Ñ†Ð¸ÐµÐ¹
doIt x = f (g (h x)) = f ((g . h) x) = (f . (g . h)) x - x Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚, Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ Ð¼Ð¾Ð¶Ð½Ð¾ ÐµÐ³Ð¾ Ñ Ð´Ð²ÑƒÑ… ÑÑ‚Ð¾Ñ€Ð¾Ð½ Ð½Ðµ Ð¿Ð¸ÑÐ°Ñ‚ÑŒ
doIt = f . g . h
-}


Ð¡Ð¿Ð¸ÑÐºÐ¸ Ð¸ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸ Ñ‚Ð¾Ð¶Ðµ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„Ð½Ñ‹, ÐºÐ°Ðº Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸
Ð¡Ð¿Ð¸ÑÐºÐ¸:
> :t [True, False] - ÑÐ¿Ð¸ÑÐ¾Ðº Ð±ÑƒÐ»ÐµÐ²Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²
:: [Bool]
> :t "aqaqa" 
:: [Char]
Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„Ð½Ð¾ÑÑ‚ÑŒ Ð² Ñ‚Ð¾Ð¼, Ñ‡Ñ‚Ð¾ Ð¼Ñ‹ Ð¼Ð¾Ð¶ÐµÐ¼ Ð·Ð°Ð¿Ð¾Ð»Ð½ÑÑ‚ÑŒ Ð»ÑŽÐ±Ñ‹Ð¼Ð¸ Ñ‚Ð¸Ð¿Ð°Ð¼Ð¸, Ð¸ Ð¾Ð½Ð¸ Ð±ÑƒÐ´ÑƒÑ‚ Ð¿Ð¾ÑÐ²Ð»ÑÑ‚ÑŒÑÑ Ð² Ð²Ñ‹Ð²Ð¾Ð´Ðµ Ñ‚Ð¸Ð¿Ð° ÑÐ¿Ð¸ÑÐºÐ° 
> :t []
:: [a]
> :t (++)
:: [a] -> [a] -> [a]
> :t (:) - Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð° Ð² Ð³Ð¾Ð»Ð¾Ð²Ñƒ ÑÐ¿Ð¸ÑÐºÐ°
:: a -> [a] -> [a]

ÐšÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸:
Ñ€Ð°Ð½ÑŒÑˆÐµ: (True, 3) - Ð´Ð²ÑƒÑ…ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð½Ñ‹Ð¹ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ - Ð¼Ð¸ÐºÑÑ„Ð¸ÑÐºÑÐ½Ñ‹Ð¹ ÑÑ‚Ð¸Ð»ÑŒ
Ñ‚ÐµÐ¿ÐµÑ€ÑŒ: (,) True 3 - Ð¿Ñ€ÐµÑ„Ð¸ÐºÑÐ½Ñ‹Ð¹ ÑÑ‚Ð¸Ð»ÑŒ ÐºÐ¾Ð½ÑÑ‚ÑƒÑ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¿Ð°Ñ€Ñ‹
(,,) True 3 'c' - Ñ‚Ð¾Ð¶Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚
> :t (,)
:: a -> b -> (a,b) - Ñ‚Ð¾Ð¶Ðµ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾Ñ€Ñ„ÐµÐ½
> let dup x = (x, x)




ÐšÐ°Ñ€Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ (Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð½Ð°Ð´ Ð¿Ð°Ñ€Ð¾Ð¹ Ð´Ð°Ð»ÐµÐµ) - Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸, Ð² ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ñ… Ð¿ÐµÑ€ÐµÐ´Ð°ÑŽÑ‚ÑÑ Ð½Ðµ Ð²ÑÐµ Ñ‚Ñ€ÐµÐ±ÑƒÐµÐ¼Ñ‹Ðµ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹, Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ Ð½Ð° Ð²Ñ‹Ñ…Ð¾Ð´Ðµ Ñ‚Ð¾Ð¶Ðµ Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°ÑŽÑ‰Ð¸Ðµ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹
Ð’ÑÑ‚Ð°ÐµÑ‚ Ð²Ð¾Ð¿Ñ€Ð¾Ñ Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´Ð° ÐºÐ°Ñ€Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… Ðº Ð½ÐµÐºÐ°Ñ€Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¼ Ð¸ Ð½Ð°Ð¾Ð±Ð¾Ñ€Ð¾Ñ‚


> fst (1,2) - Ð¼Ð¾Ð¶ÐµÐ¼ ÑÐ¼Ð¾Ñ‚Ñ€ÐµÑ‚ÑŒ ÐºÐ°Ðº Ð½Ð° Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð´Ð²ÑƒÑ… Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð², ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ð²Ð¾Ð·Ð²Ñ€ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ - Ð½ÐµÐºÐ°Ñ€Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ, Ð¾Ð½Ð° Ð½Ð° ÑÐ°Ð¼Ð¾Ð¼ Ð´ÐµÐ»Ðµ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð°
1
> :t on - Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð²Ñ‹ÑÑˆÐµÐ³Ð¾ Ð¿Ð¾Ñ€ÑÐ´ÐºÐ°, Ð¿ÐµÑ€Ð²Ñ‹Ð¹ ÐµÐµ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚ - ÐºÐ°Ñ€Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ
:: (b -> b -> c) -> (a -> b) -> a -> a -> c
> :t fst `on` (^ 2) 
error, Ð¿ÐµÑ€ÐµÐ´Ð°Ð»Ð¸ Ð½ÐµÐºÐ°Ñ€Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½ÑƒÑŽ 
> curry fst `on` (^ 2) - Ð¿Ñ€ÐµÐ²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð² ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½ÑƒÑŽ ÐºÐ°Ñ€Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½ÑƒÑŽ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð´Ð²ÑƒÑ… Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²


module Demo where

import Data.Function

avg :: (Double, Double) -> Double
avg p = (fst p + and p) / 2

avg - Ð½ÐµÐºÐ°Ñ€Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ
> curry avg `on` (^2) - Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÑÑ€ÐµÐ´Ð½ÐµÐµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ ÐºÐ²Ð°Ð´Ñ€Ð°Ñ‚Ð¾Ð² Ð´Ð²ÑƒÑ… Ð¿ÐµÑ€ÐµÐ´Ð°Ð½Ð½Ñ‹Ñ… Ð² Ð½ÐµÐµ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²
> let cur f x y = f (x,y)
cur :: ((t1, t2) -> t) -> t1 -> t2 -> t - Ð¿Ñ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚ Ð½ÐµÐºÐ°Ñ€Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½ÑƒÑŽ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð¸ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ Ð½Ð¾Ñ€Ð¼Ð°Ð»ÑŒÐ½ÑƒÑŽ
Ñƒ Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÑ‡Ð½Ð¾Ð¹ curry Ñ‚Ð¾Ñ‚ Ð¶Ðµ Ñ‚Ð¸Ð¿
> uncurry - Ð½Ð°Ð¾Ð±Ð¾Ñ€Ð¾Ñ‚




















 











	     





































    











































