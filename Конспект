1.1 –í–≤–µ–¥–µ–Ω–∏–µü§ØÔ∏è

–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä (–ö) –∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä (–ò–ü)
hs —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
–æ—Ç—Å—Ç—É–ø—ã —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω—ã
–≤—ã–∑—ã–≤–∞–µ–º—ã–π –≤ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä–µ (GHCi) —Ñ–∞–π–ª –¥–æ–ª–∂–µ–Ω —Ä–∞—Å–ø–æ–ª–∞–≥–∞—Ç—å—Å—è –≤ —Ç–æ–π –∂–µ –ø–∞–ø–∫–µ

module Test where
sayHello = putStrLn "Hello"

Prelude> :load Test - –∑–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥—É–ª—è
:reload - –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥—É–ª—è

1.2 –§—É–Ω–∫—Ü–∏–∏ü§ØÔ∏è

–ú–æ–¥–µ–ª—å –≤—ã—á–∏—Å–ª–µ–Ω–∏—è, —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –∏ –∏–º–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã—Ö —è–∑—ã–∫–æ–≤ (–∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ —è—á–µ–π–∫–∏ –ø–∞–º—è—Ç–∏)
–í —Ñ—É–Ω–∫—Ü - –ø—Ä–æ–≥—Ä–∞–º–º–∞ - –≤—ã—Ä–∞–∂–µ–Ω–∏–µ, —Ä–µ–¥—É–∫—Ü–∏–∏ –¥–æ –∫–æ–Ω—Ü–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π. –í—ã—á–∏—Å–ª–∏—Ç–µ–ª—å -
–≤–Ω–µ—à–Ω—è—è –ø—Ä–æ–≥—Ä–∞–º–º–∞
–í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –≤ —Å–∫–æ–±–∫–∞—Ö, —Å–∫–æ–±–∫–∏ –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
acos (cos pi)
–µ—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤, —Ç–æ f x y
–æ–ø–µ—Ä–∞—Ü–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–π –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–∞ –≤–ª–µ–≤–æ - (max 5) 42 = 42
(max 5) –±—É–¥–µ—Ç —Ñ—É–Ω–∫—Ü–∏–µ–π –æ–¥–Ω–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞
3 + sin 42 
3 + (max 5) 42 - —á–∞—Å—Ç–∏—á–Ω–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π

–°–∏–Ω—Ç–∞–∫—Å–∏—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π —Ñ—É–Ω–∫—Ü–∏–∏

sumSquares x y = x ^ 2 + y ^ 2
–∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏ —Å –º–∞–ª–µ–Ω—å–∫–æ–π –±—É–∫–≤—ã, –±–æ–ª—å—à–∞—è –¥–ª—è —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö
rock'n'roll = 42  
–≤ –ò–ü let func 
> func

—Å–≤–æ–π—Å—Ç–≤–æ —á–∏—Å—Ç–æ—Ç—ã —Ñ—É–Ω–∫—Ü–∏–π - –Ω–∏–∫–∞–∫–∏–µ –¥—Ä—É–≥–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –∫—Ä–æ–º–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ

let fortyTwo = 39 + 3 (always 42)
—Å–ª—É—á–∞–π–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ? –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä

—É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä
—É—Å–ª–æ–≤–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ let f x = if x > 0 then 1 else (-1) -–æ–±—ä–µ–∫—Ç—ã –æ–¥–Ω–æ–≥–æ —Ç–∏–ø–∞ –¥–æ–ª–∂–Ω—ã —Å—Ç–æ—è—Ç—å –ø–æ—Å–ª–µ –∑–µ–Ω –∏ –µ–ª—Å
f 5 = 1
f (-5) = -1 - —Å–∫–æ–±–∫–∏ –∏–º–µ—é—Ç –∑–Ω–∞—á–µ–Ω–∏–µ

let g x = (if x > 0 then 1 else (-1)) + 3

–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π —Å –ø–æ–º–æ—â—å—é —á–∞—Å—Ç–∏—á–Ω–æ–≥–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è 
let max5 x = max 5 x —Ä–∞–≤–Ω–æ—Å–∏–ª—å–Ω–æ max5' = max 5 - –±–µ—Å—Ç–æ—á–µ—á–Ω—ã–π —Å—Ç–∏–ª—å –ø—Ä–æ–≥–∏
let discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
let standardDiscount = discount 1000 5 (sum –Ω–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è)

1.3 –û–ø–µ—Ä–∞—Ç–æ—Ä—ãü§ØÔ∏è

max 6 7 - —Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã–∑—ã–≤–∞—é—Ç—Å—è –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω–æ–º —Å—Ç–∏–ª–µ
6 + 7 - –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã - –≤ –∏–Ω—Ñ–∏–∫—Å–Ω–æ–º

6 `max` 7 - —Ñ—É–Ω–∫—Ü–∏—è –≤ –æ–ø–µ—Ä–∞—Ç–æ—Ä–Ω–æ–º —Å—Ç–∏–ª–µ, –∑–∞–∫–ª—é—á–µ–Ω–∏–µ –≤ –æ–±—Ä–∞—Ç–Ω—ã–µ –∫–∞–≤—ã—á–∫–∏
(+) 6 7 - –æ–ø–µ—Ä–∞—Ç–æ—Ä –≤ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–º —Å—Ç–∏–ª–µ
–≤—Å–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –±–∏–Ω–∞—Ä–Ω—ã–µ, –ø—Ä–∏–Ω–∏–º–∞—é—Ç 2 –∑–Ω–∞—á–µ–Ω–∏—è, –∏—Å–∫–ª - –ø–µ—Ä–µ–¥ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏
–≤ —ç—Ç–æ–º –Ω–µ—É–¥–æ–±—Å—Ç–≤–æ, –ø–æ—ç—Ç–æ–º—É –∫–æ–≥–¥–∞ –æ—Ç—Ä–∏—Ü —á–∏—Å–ª–æ –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–µ —Ñ—É–Ω–∫—Ü–∏–∏, —Ç–æ –µ–≥–æ –Ω–∞–¥–æ –∑–∞–∫–ª—é—á–∞—Ç—å –≤ —Å–∫–æ–±–∫–∏, —Ç–∫ –∏–Ω–∞—á–µ –±—É–¥–µ—Ç —Ñ—É–Ω–∫—Ü–∏—è –º–∏–Ω—É—Å —á–∏—Å–ª–æ

–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
3 + 5 * 8 = 43
–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ—Ç 0 –¥–æ 9 –æ–±–æ–∑–Ω–∞—á–∞–µ—Ç—Å—è, –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Ñ—É–Ω–∫—Ü–∏–π - —Å–∞–º—ã–π –≤—ã—Å–æ–∫–∏–π (10)

–∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å
(3 - (9) - 5)
–æ–ø–µ—Ä–∞—Ç–æ—Ä –≤—ã—á–∏—Ç–∞–Ω–∏—è –ª–µ–≤–æ-–∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω—ã–π
–∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ infixl, infixr, infix (–Ω–µ —Ö–æ—Ç–∏–º —É–∫–∞–∑—ã–≤–∞—Ç—å –ª–µ–≤–æ–ø—Ä–∞–≤–æ), –ø–æ—Ç–æ–º —É—Ä–æ–≤–µ–Ω—å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ –∏ –∏–º—è (–æ–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ)

–∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
infixr 8 ^, `logBase` - –ø—Ä–∞–≤–∞—è –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å, 8 —É—Ä–æ–≤–µ–Ω—å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞. –§—É–Ω–∫—Ü–∏—è –ª–æ–≥–±–µ–π–∑ –∫–∞–∫ –æ–ø–µ—Ä–∞—Ç–æ—Ä —Ç–∞–∫–∞—è –∂–µ
infixl 7 *, /, `div`, `mod`
infixl 6 +, -
infix 4 ==, /=, >, >=, <, <=
–∫–æ–≥–¥–∞ –Ω–∏—á–µ–≥–æ –Ω–µ –∑–∞–¥–∞–Ω–æ, —Ç–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∞—Å—Å–æ—Ü –ª–µ–≤–∞—è, –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç 9

–Ω–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤, –≤—Å–µ –æ–Ω–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ
–º–æ–∂–Ω–æ —Å–∞–º–æ–º—É –¥–µ–ª–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –∏–∑ –Ω–∞–±–æ—Ä–∞ —Å–∏–º–≤–æ–ª–æ–≤ 
{! # $ % * + . / < = > ? @ \ ^ | - ~} - —Ä–∞–≤–Ω–æ–∑–Ω–∞—á–Ω—ã
–º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ—â–µ :, –Ω–æ –Ω–µ –≤ –Ω–∞—á–∞–ª–µ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞

module Demo where

infixl 6 *+*

a *+* b = a ^ 2 + b ^ 2 (—Ä–∞–≤–Ω–æ—Å–∏–ª—å–Ω–æ (*+*) a b = a ^ 2 + b ^ 2)

–µ–≥–æ –º–æ–∂–Ω–æ –±—ã–ª–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –≤ –≤–∏–¥–µ 3 *+* 4 = 25 –∏ (*+*) 3 4

—á–∞—Å—Ç–∏—á–Ω–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –∫ –æ–¥–Ω–æ–º—É –∏–∑ —Å–≤–æ–∏—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
(/) 2 —ç–∫–≤–∏–≤ (2 /) - —Å–µ—á–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ (—Ñ—É–Ω–∫—Ü–∏—è –æ–¥–Ω–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞)
(2 /) 4 = 0.5 –¥–≤–∞ –¥–µ–ª–∏—Ç—å –Ω–∞ 4 —Ä–∞–≤–Ω–æ 1/2
(/ 2) 4 = 2 —á–µ—Ç—ã—Ä–µ –¥–µ–ª–∏—Ç—å –Ω–∞ –¥–≤–∞ —Ä–∞–≤–Ω–æ 2
–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã —Å–∫–æ–±–∫–∏
–µ—Å—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ (- 2) - —ç—Ç–æ –Ω–µ —Å–µ—á–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ -, –∞ —á–∏—Å–ª–æ -2

–∑–Ω–∞—á–æ–∫ –ø—Ä–æ–±–µ–ª–∞
module Demo where

f $ x = f x
sin 0 = 0 —ç–∫–≤–∏–≤ sin $ 0 = 0
–æ–ø–µ—Ä–∞—Ç–æ—Ä –¥–æ–ª–ª–∞—Ä —Å–∞–º—ã–π –Ω–∏–∑–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏–º–µ–µ—Ç, –∏–º –º–æ–∂–Ω–æ –æ—Ç —Å–∫–æ–±–æ–∫ –∏–∑–±–∞–≤–ª—è—Ç—å—Å—è
sin (pi / 2) —ç–∫–≤–∏–≤ sin $ pi / 2
—É –¥–æ–ª–ª–∞—Ä–∞ –ø—Ä–∞–≤–∞—è –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å

{--} - comment
{- f (g x (h y)) == f $ g x (h y) == f $ g x $ h y -}

logBase x $ y –º–µ–∂–¥—É –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏ —ç—Ç—É —Ö—Ä–µ–Ω—å –Ω–∞–¥–æ —Å—Ç–∞–≤–∏—Ç—å........

–ë–∞–∑–æ–≤—ã–µ —Ç–∏–ø—ãü§ØÔ∏è

–¢–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —è–∑—ã–∫ —Å–æ —Å—Ç—Ä–æ–≥–æ–π (–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–µ—è–≤–Ω–æ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–æ–≤) —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–π (–ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –Ω–µ –≤–æ –≤—Ä–µ–º—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è, –∞ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏) —Å–∏—Å—Ç–µ–º–æ–π —Ç–∏–ø–∏–∑–∞—Ü–∏–∏

–≤—ã—è—Å–Ω–µ–Ω–∏–µ —Ç–∏–ø–æ–≤ - –∫–æ–º–∞–Ω–¥–∞ :type 
> :type 'c' 
'c' :: Char
'\n' is char too
> :type 'zz' - error
> :type True = Type :: Bool
> :t False -//-

–µ—Å—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –Ω–∞–±–æ—Ä —Ç–∏–ø–æ–≤, common name Num
> :t 3
3 :: Num a => a

> let x = 3 :: Int

> :t 3.5
Fractional a => a

Function type is declared by binary operator - arrow (->) (infixr)
not False = True 
> :t not 
not :: Bool -> Bool

> (&&) False True (logical operator && in functional style, returns True if both of arguments are true)
False

> ((&&) False) True 
        |        |
    Bool func Bool item
eventually, type of && is Bool -> (Bool -> Bool) (input: Bool, output: func Bool -> Bool)
parentheses may be not mentioned, finally 
> :t (&&)
(&&) :: Bool -> Bool -> Bool
number of arguments the same as number of arrows

–¢–∏–ø —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–∂–Ω–æ –∑–∞–¥–∞—Ç—å –≤ —Ñ–∞–π–ª–µ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ –≤–º–µ—Å—Ç–µ —Å –µ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º:

discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum

–û—Ç–º–µ—Ç–∏–º, —á—Ç–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, —Ö–æ—Ç—è —á–∞—Å—Ç–æ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏. –ï–≥–æ –æ–±—ã—á–Ω–æ —Ä–∞—Å–ø–æ–ª–∞–≥–∞—é—Ç –ø–µ—Ä–µ–¥ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º —Ñ—É–Ω–∫—Ü–∏–∏, —Ö–æ—Ç—è —ç—Ç–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è –º–æ–∂–Ω–æ —Ä–∞—Å–ø–æ–ª–æ–∂–∏—Ç—å –≤ –ª—é–±–æ–º –º–µ—Å—Ç–µ —Ñ–∞–π–ª–∞ —Å –∏—Å—Ö–æ–¥–Ω—ã–º –∫–æ–¥–æ–º

–Ω–µ –≤—Å–µ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã —á–µ—Ä–µ–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –ø—Ä–µ–ª—é–¥–∏—é, –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –Ω—É–∂–µ–Ω –Ω–æ–≤—ã–π –º–æ–¥—É–ª—å –∏ –∏–º–ø–æ—Ä—Ç –µ–≥–æ

module Demo where

import Data.Char

test = isDigit '7'

output = True

import of module may be done in ghci directly

–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é twoDigits2Int, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –¥–≤–∞ —Å–∏–º–≤–æ–ª–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∏—Å–ª–æ, —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–µ –∏–∑ —ç—Ç–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤, –µ—Å–ª–∏ –æ–±–∞ —Å–∏–º–≤–æ–ª–∞ —á–∏—Å–ª–æ–≤—ã–µ, –∏ 100 –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ. (–ü–µ—Ä–≤—ã–π —Å–∏–º–≤–æ–ª —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç—Å—è –∫–∞–∫ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Å—è—Ç–∫–æ–≤, –≤—Ç–æ—Ä–æ–π ‚Äî –µ–¥–∏–Ω–∏—Ü.)

import Data.Char
twoDigits2Int :: Char -> Char -> Int
twoDigits2Int x y = if isDigit x && isDigit y == True then digitToInt x * 10 + digitToInt y else 100 

–ö–æ—Ä—Ç–µ–∂ - —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π –Ω–∞–±–æ—Ä —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã, —Ç–∏–ø —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–± –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π
> (2, True) - 2-items kortege
(2, True) 
> fst (2, True)
2
> snd (2, True)
True
> :t ('x', True)
('x', True) :: (Char, Bool)

> (3) - one-element kortege does not exist! but exists empty kortege
> ()
()
> :t ()
() :: () 

–°–ø–∏—Å–∫–∏ - –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–Ω—ã–µ —Ç–∏–ø—ã, –Ω–æ –µ—Å—Ç—å –¥–≤–∞ –æ—Ç–ª–∏—á–∏—è –æ—Ç –∫–æ—Ä—Ç–µ–∂–µ–π:
1. –°–ø–∏—Å–∫–∏ –≥–æ–º–æ–≥–µ–Ω–Ω—ã (–∫–æ—Ä—Ç–µ–∂–∏ –≥–µ—Ç–µ—Ä–æ–≥–µ–Ω–Ω—ã) - –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å–ø–∏—Å–∫–∞ –¥–æ–ª–∂–Ω—ã –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç—å –∫ –æ–¥–Ω–æ–º—É —Ç–∏–ø—É
2. –î–ª–∏–Ω–∞ —Å–ø–∏—Å–∫–∞ –Ω–µ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞ –∏ –Ω–µ –∏–∑–≤–µ—Å—Ç–Ω–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É

> [1,2,3] - list of digits
> [False, True]
> :t [False, True]
[False, True] :: [Bool]
 
For char there is a special form of otput list - string
> ['H', 'i']
"Hi"
> "Hi" :: String


: - operator of adding one element at the head of a list
> let str = 'H' : "ello"
> str
"Hello"

++ - concatenation of two lists
> str ++ " world"
"Hello world"

1.5 –†–µ–∫—É—Ä—Å–∏—è ü§ØÔ∏è

–í —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö —è–∑—ã–∫–∞—Ö –Ω–µ—Ç –ø–æ–Ω—è—Ç–∏—è —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∏ —Ü–∏–∫–ª –∑–∞–º–µ–Ω—è–µ—Ç—Å—è —Ä–µ–∫—É—Ä—Å–∏–µ–π.

factorial n = if n == 0 then 1 else n * factorial (n - 1)

To avoid cycles we need 
1.to put not the same value of parameter in the right part of the func towards left part of the func (n =! n - 1)
2.terminate condition (if n == 0 then 1) reqursion interrupts


{-
factorial 2
 ~> if 2 == 0 then 1 else 2 * factorial 1
 ~> 2 * factorial 1
 ~> 2 * (if 1 == 0 then 1 else 1 * factorial 0)
 ~> 2 * 1 * factorial 0
 ~> 2 * factorial 0
 ~> 2 * (if 0 == 0 then 1 else 0 * factorial(-1))
 ~> 2 * 1
 ~> 2
-}

calculations are made directly in language

if-then-else is not comfortable enough for using, so exists comparement with origin: not alone equation

factorial' 0 = 1
factorial' n = n * factorial' (n - 1)

another description of parameters
n - irrefutable origin

reqursion from negative argument - fail
funcs error & indefined

> error "ABC" - outputs error message
*** Exception: ABC
> undefined - interrupts code immediately
*** Exception: Prelude.undefined 

undefined returns bottom symbol, it is used as an element of all types

adjusting
factorial'' 0 = 1
factorial'' n = if n < 0 then error "arg must be >= 0" else n * factorial'' (n - 1)

> factorial'' (-3) 
*** -/-

comparement with origin is not universal method, so there are guards
factorial''' 0 = 1
factorial''' n | n < 0 = error "arg must be >= 0" //guard 1
               | n > 0 = n * factorial''' (n - 1) //guard 2
bool
factorial4 n | n == 0		= 1
	     | n < 0 		= n * factorial''' (n - 1) 
             | otherwise 	= error "arg must be >= 0"

otherwise = True

we also may develop smth like loop by additional variable
factorial5 n | n >= 0 	= helper 1 n
	     | otherwise = error "arg must be >= 0"
	     
helper acc 0 = acc
helper acc n = helper (acc * n) (n - 1)

raise effectivity


1.6 –õ–æ–∫–∞–ª—å–Ω—ã–µ —Å–≤—è–∑—ã–≤–∞–Ω–∏—è –∏ –ø—Ä–∞–≤–∏–ª–∞ –æ—Ç—Å—Ç—É–ø–æ–≤ ü§ØÔ∏è

–î–≤—É–º–µ—Ä–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å, —Ä–∞—Å–ø–æ–∑–Ω–∞—é—Ç—Å—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º
—Ç–∞–± - 8 –ø—Ä–æ–±–µ–ª–æ–≤
—É–≤–µ–ª–∏—á–µ–Ω–∏–µ –æ—Ç—Å—Ç—É–ø–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ, —É–º–µ–Ω—å—à–µ–Ω–∏–µ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –ø—Ä–æ–±–ª–µ–º–∞–º

module Demo where

roots:: Double -> Double -> Double 
	-> (Double, Double) it is law-acceptable
roots a b c = 
  (
    (-b - sqrt (b^2 - 4 * a * c)) / (2 * a)
  ,
    (-b + sqrt (b^2 - 4 * a * c)) / (2 * a)
  )
  
null tab is global declaration
in a body of a func we can use any non-null tap

–≤ –∫–æ–¥–µ –≤—ã—à–µ –∫–æ–ø–∏—Ä—É–µ—Ç—Å—è –∫–æ—Ä–µ–Ω—å –∏–∑ –¥–∏—Å–∫—Ä–∏–º, —Ö–æ—á–µ—Ç—Å—è –∑–∞–≤–µ—Å—Ç–∏ –ª–æ–∫–∞–ª—å–Ω–æ-–æ–ø—Ä–µ–¥ –ø–µ—Ä–µ–º–µ–Ω –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–µ (let in)


roots' a b c = 
    let d = sqrt (b^2 - 4 * a * c) in 
    ((-b - d) / (2 * a), (-b + d) / (2 * a))

//e.g. let k in f(k)

> let x = True in (True, x)
(True, True)

let in can declare multiple bindings

roots'' a b c = 
    let {d = sqrt (b^2 - 4 * a * c); x1 = (-b - d) / (2 * a); x2 = (-b + d) / (2 * a)} in 
    (x1, x2)
    
more comfortable is version of declaring with tabs instead of ;
roots''' a b c =
 let
    x1 = (-b - d) / aTwice
    x1 = (-b + d) / aTwice
    d = sqrt $ b^2 - 4 * a * c
    aTwice = 2 * a
 in (x1, x2)
 
local bindings must have the same size of tabs

also we can declare local functions

factorial5 n | n >= 0 	= helper 1 n
	     | otherwise = error "arg must be >= 0"
	     
helper acc 0 = acc
helper acc n = helper (acc * n) (n - 1)

factorial6 n 
	| n >= 0 = let
	    helper acc 0 = acc
	    helper acc n = helper (acc * n) (n - 1)
	  in helper 1 n
	| otherwise = error "arg must be >= 0"

also exists local binding of origins

rootsDiff a b c = let
   (x1, x2) = roots a b c
   in x2 - x1
   
(x2, x1) - origin (//aka local variable in other lang-s)

local bindings with 'where'
where^(-1) = let in

roots''' a b c =
 let
    x1 = (-b - d) / aTwice
    x1 = (-b + d) / aTwice
    d = sqrt $ b^2 - 4 * a * c
    aTwice = 2 * a
 in (x1, x2)
 
roots'''' a b c = (x1, x2) where
    x1 = (-b - d) / aTwice
    x2 = (-b + d) / aTwice
    d = sqrt $ b^2 - 4 * a * c
    aTwice = 2 * a
    
differency in properties 

> let x = 2 in x^2
4
> x^2 where x = 2 
does not work

factorial6 n 
	| n >= 0 = let
	    helper acc 0 = acc
	    helper acc n = helper (acc * n) (n - 1)
	  in helper 1 n
	| otherwise = error "arg must be >= 0"

factorial7 n 
	| n >= 0 	= helper 1 n
	| otherwise 	= error "arg must be >= 0"
 where
  helper acc 0 = acc
  helper acc n = helper (acc * n) (n - 1)
  
in factorial7 we can use helper in all guards



2.1 –ü–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º (1) ü§ØÔ∏è

–§—É–Ω–∫—Ü–∏—è –æ–±–ª–∞–¥–∞–µ—Ç –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã–º –ø–æ–≤–µ–¥–µ–Ω–∏–µ–º, –µ—Å–ª–∏ –æ–Ω–∞ –º.–±. –≤—ã–∑–≤–∞–Ω–∞ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è—Ö —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ (int + int, double + double, + –ø–æ–ª–∏–º–æ—Ä—Ñ–µ–Ω)

2 —Ç–∏–ø–∞: –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π

–ü–∞—Ä–∞–º: –∫–æ–¥ —Ñ—É–Ω–∫—Ü–∏–∏ –æ–¥–∏–Ω–∞–∫–æ–≤ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤

+ - —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π, –ø–æ—Ç–æ–º—É —á—Ç–æ —á–∏—Å–ª–∞ –Ω–∞ –Ω–∏–∑–∫–æ–º —É—Ä–æ–≤–Ω–µ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏ (—Ñ–ª–æ—Ç, –∏–Ω—Ç) —Å–∫–ª–∞–¥—ã–≤–∞—é—Ç—Å—è –ø–æ-—Ä–∞–∑–Ω–æ–º—É

–ü—Ä–∏–º–µ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏ –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
>let id x = x
>id :: t -> t //t - –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–π —Ç–∏–ø, –ª—é–±–æ–µ –≤–º–µ—Å—Ç–æ –Ω–µ–≥–æ –º–æ–∂–Ω–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å


>id id
> :t (id id) 
(t -> t) -> (t -> t) = t -> t


> let k x y = x
> k 42 True
42
> :t k
k :: t1 -> t -> t1
> :t const - —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
a -> b -> a

> undefined //–∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è, —Ç–∏–ø –ª—é–±–æ–π, –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã
*** exception

–º–æ–∂–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å —Å—Ç–µ–ø–µ–Ω—å –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º–∞ —Ñ—É–Ω–∫—Ü–∏–∏, —è–≤–Ω–æ —É–∫–∞–∑–∞–≤ –µ–µ —Ç–∏–ø

mono :: Char -> Char //–º–æ–Ω–æ–º–æ—Ä—Ñ–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Å –±–æ–ª–µ–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º —Ç–∏–ø–æ–º, —á–µ–º id
mono x = x


semiMono :: Char -> a -> Char //—á–∞—Å—Ç–∏—á–Ω–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º–∞
semiMono x y = x


—Ñ—É–Ω–∫—Ü–∏—è –≤—ã—Å—à–∏—Ö –ø–æ—Ä—è–¥–∫–æ–≤ - —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –¥—Ä—É–≥—É—é —Ñ—É–Ω–∫—Ü–∏—é, –ø—Ä–∏–º–µ—Ä –≤ —Å–∏ - qsort

> :t ($)
(a -> b) -> a -> b    //()-—Ñ—Ü–∏—è, –∞—Ä–≥—É–º–µ–Ω—Ç - –ø—Ä–∏–º–µ–Ω—è–µ—Ç —Ñ—Ü–∏—é –∫ –∞—Ä–≥—É–º–µ–Ω—Ç—É 

> :t apply2 f x = f (f x)
(t -> t) -> t -> t //–∑–¥–µ—Å—å a –∏ b - –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ = t 

> apply2 (+5) 22
32
> apply (++ "AB") "CD"
"CDABAB"

flip f y x = f x y - standard lib

> flip (/) 4 2
0.5
> (/) 4 2
2

> flip const 5 True
True

–µ—Å—Ç—å –∞–Ω–æ–Ω–∏–º–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
> 2 * x + 7
error
>let f x = 2 * x + 7
> f 10
27

–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ (–ª—è–º–±–¥–∞-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ)
> (\x -> 2 * x + 7) 10
27

> let f' = \x -> 2 * x + 7
> f' 10
27

> let lenVec x y = sqrt $ x^2 + y^2
> let lenVec = \x -> \y-> sqrt $ x^2 + y^2
> lenVec 3 4 
5
–º–æ–∂–Ω–æ –µ—â–µ —Ç–∞–∫ 
> let lenVec = \x y -> sqrt $ x^2 + y^2

—á–∞—Å—Ç–æ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –≤ —Ñ—É–Ω–∫—Ü–∏—è—Ö –≤—ã—Å—à–∏—Ö –ø–æ—Ä—è–¥–∫–æ–≤

> let p1 = ((1,2), (3,4))
> let p2 = ((3,4), (5,6))
> fst $ fst p1
1


sumFstFst = (+) `on` helper
	where helper pp = fst $ fst pp
	

>sumFstFst p1 p2 
4 //—Å–ª–æ–∂–∏–ª–∏—Å—å –ø–µ—Ä–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ø–∞—Ä

–ù–û 
sumFstFst' = (+) `on` (\pp -> fst $ fst pp) - —Ç–∞–∫ –≥–æ—Ä–∞–∑–¥–æ –ª—É—á—à–µ


2.2 –ü–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º (2) ü§ØÔ∏è

f –∏ g, –Ω–∞–¥–æ –Ω–∞–ø–∏—Å–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏
> f :: b -> c
> g :: a -> b
> x :: a

> f (g x) :: c 
–Ω–∞–ø–∏—à–µ–º —Ç–µ–ø–µ—Ä—å —Ñ—É–Ω–∫—Ü–∏—é, —Ç–æ –µ—Å—Ç—å –∞–±—Å—Ç—Ä–∞–≥–∏—Ä—É–µ–º—Å—è –ø–æ –∏–∫—Å—É, —Ç–æ –µ—Å—Ç—å –Ω–∞–ø–∏—à–µ–º –ª—è–º–±–¥–∞-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ
—É—Å–ª–æ–≤–Ω–æ h x = f (g x) - –ø–µ—Ä–µ–º–µ—â–∞–µ–º –∏–∫—Å –≤–ø—Ä–∞–≤–æ –∏ —É–±–∏—Ä–∞–µ–º —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∞—à
> \x -> f (g x) :: a -> c
> let compose f g = \x -> f (g x)
> :t compose
compose :: (t1 -> t) -> (t2 - t1) -> t2 -> t1 aka a b c

–≤ —Ö–∞—Å–∫–µ–ª–ª–µ —É–∂–µ –æ–ø–µ—Ä–µ–¥–µ–ª–µ–Ω —Ç–∏–ø –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –∫–∞–∫ –≤—ã—à–µ:
> :i (.) // :i - info


–±—ã–ª–æ —Ä–∞–Ω—å—à–µ:
sumFstFst' = (+) `on` (\pp -> fst $ fst pp) - —Ç–∞–∫ –≥–æ—Ä–∞–∑–¥–æ –ª—É—á—à–µ

sumFstFst'' = (+) `on` (fst . fst)

{-
–¶–µ–ø–æ—á–∫–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–π –º.–±. –∑–∞–º–µ–Ω–µ–Ω–∞ –∫–æ–º–ø–æ–∑–∏—Ü–∏–µ–π
doIt x = f (g (h x)) = f ((g . h) x) = (f . (g . h)) x - x –ø–æ—Å–ª–µ–¥–Ω–∏–π –∞—Ä–≥—É–º–µ–Ω—Ç, –ø–æ—ç—Ç–æ–º—É –º–æ–∂–Ω–æ –µ–≥–æ —Å –¥–≤—É—Ö —Å—Ç–æ—Ä–æ–Ω –Ω–µ –ø–∏—Å–∞—Ç—å
doIt = f . g . h
-}


–°–ø–∏—Å–∫–∏ –∏ –∫–æ—Ä—Ç–µ–∂–∏ —Ç–æ–∂–µ –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã, –∫–∞–∫ –∏ —Ñ—É–Ω–∫—Ü–∏–∏
–°–ø–∏—Å–∫–∏:
> :t [True, False] - —Å–ø–∏—Å–æ–∫ –±—É–ª–µ–≤—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
:: [Bool]
> :t "aqaqa" 
:: [Char]
–ø–æ–ª–∏–º–æ—Ä—Ñ–Ω–æ—Å—Ç—å –≤ —Ç–æ–º, —á—Ç–æ –º—ã –º–æ–∂–µ–º –∑–∞–ø–æ–ª–Ω—è—Ç—å –ª—é–±—ã–º–∏ —Ç–∏–ø–∞–º–∏, –∏ –æ–Ω–∏ –±—É–¥—É—Ç –ø–æ—è–≤–ª—è—Ç—å—Å—è –≤ –≤—ã–≤–æ–¥–µ —Ç–∏–ø–∞ —Å–ø–∏—Å–∫–∞ 
> :t []
:: [a]
> :t (++)
:: [a] -> [a] -> [a]
> :t (:) - –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –≥–æ–ª–æ–≤—É —Å–ø–∏—Å–∫–∞
:: a -> [a] -> [a]

–ö–æ—Ä—Ç–µ–∂–∏:
—Ä–∞–Ω—å—à–µ: (True, 3) - –¥–≤—É—Ö—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–π –∫–æ—Ä—Ç–µ–∂ - –º–∏–∫—Å—Ñ–∏—Å–∫—Å–Ω—ã–π —Å—Ç–∏–ª—å
—Ç–µ–ø–µ—Ä—å: (,) True 3 - –ø—Ä–µ—Ñ–∏–∫—Å–Ω—ã–π —Å—Ç–∏–ª—å –∫–æ–Ω—Å—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∞—Ä—ã
(,,) True 3 'c' - —Ç–æ–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
> :t (,)
:: a -> b -> (a,b) - —Ç–æ–∂–µ –ø–æ–ª–∏–º–æ—Ä—Ñ–µ–Ω
> let dup x = (x, x)




–ö–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (—Ñ—É–Ω–∫—Ü–∏—è –Ω–∞–¥ –ø–∞—Ä–æ–π –¥–∞–ª–µ–µ) - —Ñ—É–Ω–∫—Ü–∏–∏, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –Ω–µ –≤—Å–µ —Ç—Ä–µ–±—É–µ–º—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã, –ø–æ—ç—Ç–æ–º—É –Ω–∞ –≤—ã—Ö–æ–¥–µ —Ç–æ–∂–µ –ø–æ–ª—É—á–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è —Ç—Ä–µ–±—É–µ—Ç –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã
–í—Å—Ç–∞–µ—Ç –≤–æ–ø—Ä–æ—Å –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫ –Ω–µ–∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∏ –Ω–∞–æ–±–æ—Ä–æ—Ç


> fst (1,2) - –º–æ–∂–µ–º —Å–º–æ—Ç—Ä–µ—Ç—å –∫–∞–∫ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—é –¥–≤—É—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ - –Ω–µ–∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è, –æ–Ω–∞ –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –æ–¥–Ω–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞
1
> :t on - —Ñ—É–Ω–∫—Ü–∏—è –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞, –ø–µ—Ä–≤—ã–π –µ–µ –∞—Ä–≥—É–º–µ–Ω—Ç - –∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
:: (b -> b -> c) -> (a -> b) -> a -> a -> c
> :t fst `on` (^ 2) 
error, –ø–µ—Ä–µ–¥–∞–ª–∏ –Ω–µ–∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—É—é 
> curry fst `on` (^ 2) - –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–≤—É—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤


module Demo where

import Data.Function

avg :: (Double, Double) -> Double
avg p = (fst p + and p) / 2

avg - –Ω–µ–∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è
> curry avg `on` (^2) - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ –¥–≤—É—Ö –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã—Ö –≤ –Ω–µ–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
> let cur f x y = f (x,y)
cur :: ((t1, t2) -> t) -> t1 -> t2 -> t - –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –Ω–µ–∫–∞—Ä—Ä–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –∏ –≤–æ–∑–≤—Ä–∞—â –Ω–æ—Ä–º–∞–ª—å–Ω—É—é
—É –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–π curry —Ç–æ—Ç –∂–µ —Ç–∏–ø
> uncurry - –Ω–∞–æ–±–æ—Ä–æ—Ç


2.3 –ö–ª–∞—Å—Å—ã —Ç–∏–ø–æ–≤ ü§ØÔ∏è

–ü–æ–≥–æ–≤–æ—Ä–∏–º –ø—Ä–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º
–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å - –∫–ª–∞—Å—Å —Ç–∏–ø–æ–≤, –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ

> :t 7
:: Num a(–∫–æ–Ω—Ç–µ–∫—Å—Ç - –∏–º—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∫ —Ç–∏–ø—É (–∞–∫–∞ –Ω–∞–∫–ª–∞–¥—ã–≤–∞–Ω–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –Ω–∞ —Ç–∏–ø)) => a (—Ç–∏–ø) - –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã–π —Ç–∏–ø

> :t (+)
:: Num a => a -> a -> a

> :t (>)
:: Ord a => a -> a -> Bool // a –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª–µ–º –∫–ª–∞—Å—Å–∞ —Ç–∏–ø–æ–≤ Ord

> :t (> 7) - —Å–µ—á–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –±–æ–ª—å—à–µ —á–∏—Å–ª–æ–º 7
:: (Num a, Ord a) => a -> Bool

> :t (> (1, 2))
:: (Num t, Num t1, Ord t, Ord t1) => (t, t1) -> Bool //t t1 —Ç–∫ –≤ –ø–∞—Ä–µ –º–æ–≥—É—Ç –±—ã—Ç—å —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã

> :t (* 'c')
error

class Eq a where
    (==) :: a -> a -> Bool --numerate of functions' signatures
    (/=) :: a -> a -> Bool

{-
> :t (== 42)
:: (Eq a, Num a) => a -> Bool
-}

> :t elem - –ø—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª –ª–∏ —ç–ª–µ–º–µ–Ω—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–º —Å–ø–∏—Å–∫–∞
:: Eq a => a -> [a] -> Bool

–†–∞–∑–≥–æ–≤–æ—Ä –æ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—è—Ö –∫–ª–∞—Å—Å–∞ —Ç–∏–ø–æ–≤ + –º–µ—Ç–æ–¥—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

class Eq a where
    (==), (/=) :: a -> a -> Bool --numerate of functions' signatures
    x /= y = not (x == y)
    x = y = not (x /= y)

instance Eq Bool where
    True == True = True
    False == False = True
    _ == _ = False -- _ otherwise for all cases

    -- x /= y = not (x == y) that expression suits all the instances of class, 
    -- so we can raise it up straight to the class. We can overcover default definition

{- 
> :t (== 42)
:: (Eq a, Num a) => a -> Bool
-}

instance –º–± –∏ –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã–π —Ç–∏–ø, –Ω–∞–ø—Ä–∏–º–µ—Ä –ø–∞—Ä–∞
—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç–∏–ø—ã –Ω–µ –º–æ–≥—É—Ç —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å—Å—è –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞, —Ç–µ –Ω–µ —è–≤–ª –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—è–º–∏ –∫–ª–∞—Å—Å–∞ Eq


2.4 –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∫–ª–∞—Å—Å—ã —Ç–∏–ø–æ–≤ ü§ØÔ∏è

class extension - —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
–∫–∞–∫ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –≤ –æ–æ–ø - –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤


module Demo where

class Eq a where
    (==), (/=) :: a -> a -> Bool --numerate of functions' signatures
    x /= y = not (x == y)
    x = y = not (x /= y)
    
//—ç—Ç–æ –Ω–∞—Å–ª–µ–¥–Ω–∏–∫ –±—É–¥–µ—Ç
class (Eq a) => Ord a where //(Eq a) => - –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –∫–ª–∞—Å—Å–∞ —Ç–∏–ø–æ–≤ Ord, Ord —Ä–∞—Å—à–∏—Ä—è–µ—Ç Eq
    (<), (<=), (>=), (>) :: a -> a -> Bool
    max, min :: a -> a -> a
    compare :: a -> a -> Ordering
{-Minimal complete definition: either compare or <= -} 

> :t Ordering
data Ordering = LT | EQ | GT - 3 –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞, 3 —ç–ª–µ–º–µ–Ω—Ç–∞ (–º–µ–Ω—å—à–µ, —ç–∫–≤–∏–≤, –±–æ–ª—å—à–µ)

//–º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Ç–∞–∫–∂–µ –¥–æ–ø—É—Å—Ç–∏–º–æ
class (Eq a, Printable a) => MyClass a where
	... 
	
–ø–æ–¥ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ–º –ø–æ–Ω–∏–º–∞–µ—Ç—Å—è –Ω–µ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–π, –∞ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤

–ø—Ä–æ –º–µ—Ç–æ–¥ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤—Ö–æ–¥–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤ –µ–≥–æ —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
>:t show
show :: Show a => a -> String

> show 5.0
"5.0"

> :t read
read :: Read a => String -> a

> read "5" - error, –Ω–∞–¥–æ —Å–Ω—è—Ç—å –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º 5
> read "5" :: Int
5

> read "5 rings" :: Int - error

> reads "5 rings" :: [(Int, String)]
[(5, "rings")]


module Demo where

class Enum a where 
	succ, pred :: a -> a
	toEnum :: Int -> a
	fromEnum :: a -> Int
	
–∏—Ç–µ—Ä–∞—Ü–∏–∏ –ø–æ —Ç–∏–ø—É
> succ 4 
5
> pred 4
3
> pred 'z'
'y'
> succ 'z'
'{'

> fromEnum 'z'
122 - ascii code
> toEnum 122 :: Char
'z'

class Bounded a where
	minBound, maxBound
	
> succ False 
True
> succ True
max ...

> minBound :: Bool
False
> maxBound :: Bool 
True


>minBound :: Int
-9223372036854775808 - 64bit platform 


> maxBound :: Integer 
error (Integer - –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ç–∏–ø, –Ω–µ—Ç –≥—Ä–∞–Ω–∏—Ü) 


–ø—Ä–æ –∫–ª–∞—Å—Å —Ç–∏–ø–æ–≤ Num

module Demo where

class Num a where
	(+), (-), (*) :: a -> a -> a //–¥–µ–ª–µ–Ω–∏–µ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ, –æ–Ω–æ –≤—Å–µ –≤ –Ω–∞—Å–ª–µ–¥–Ω–∏–∫–∞—Ö —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –∏ —É –≤—Å–µ—Ö –ø–æ-—Ä–∞–∑–Ω–æ–º—É
	negate :: a -> a
	abs :: a -> a
	signum :: a -> a
	fromInteger :: Integer -> a
	
	x - y = x + negate y
	negate x = 0 - x
	
{-LAW    abs x * signum x == x -}


> :i Fractional - Num —Å –¥–µ–ª–µ–Ω–∏–µ–º
> :i RealFrac - –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ


avg :: Int -> Int -> Int -> Double
avg x y z = (fromInteger (toInteger x + toInteger y + toInteger z)) /  3.0

 




	



























 











	     





































    











































